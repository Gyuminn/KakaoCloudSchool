## 비동기 처리

1. **비동기 처리**

   1. 동기(Synchronous)와 비동기(Asynchronous)

      동기: 순차적으로 처리. 하나의 처리가 끝나야 다음을 처리하는 형태.

      비동기: 하나의 처리가 끝나기 전에 다른 처리를 할 수 있는 형태.

      시간이 오래 걸리는 작업의 경우 작업을 순차적으로 처리하게 되면 뒤의 작업이 너무 오래 기달려야 하고 동일한 자원을 사용하지 않는 작업을 순서대로 처리하게 되면 자원의 낭비가 발생하게 된다.

      작업을 수행하다가 쉬는 시간이 생기거나 일정한 시간 이상 작업을 하거나 프로세서를 사용하지 않는 작업(입출력 작업 - 디스크나 네트워크에서 데이터를 받아오거나 전송하는 작업)을 수행하는 경우 다른 작업을 수행할 수 있도록 하는 방식.

      알림을 어떻게 줄 것인가를 고민해야 한다.

      비동기로 동작한 작업이 끝나고 난 후 작업을 어떻게 할 것인가 하는 문제

      Callback 함수 → Promise → async/await

   2. callback

      상태 변화가 생기면 호출되는 함수를 callback function이라고 한다.

      비동기 처리는 언제 작업이 종료될지 알 수 없기 때문에 작업이 종료되면 다른 작업을 수행할 수 있도록 콜백 함수를 등록할 수 있게 해준다.

      ```jsx
      window.addEventListener("load", 함수);
      처리내용;

      // 브라우저가 html파일을 전부 읽어서 메모리에 적재를 하고 나면 함수를 호출한다.
      // 모든 이벤트 처리는 비동기 방식이다.
      // 함수는 load가 끝나면 호출되기 때문에 콜백 함수라고 한다.
      ```

   3. 비동기 처리를 수행해야 하는 경우
      - 입출력 작업
        파일에 읽고 쓰기
        서버에 요청하고 응답을 받는 것 - 느리기 때문
      - 암호화/복호화 작업(애매하다 - 블록체인 때문)
        오랜 시간이 걸리기 때문에 비동기적으로 처리하는 것을 기본으로 한다.
   4. Promise

      비동기 처리를 수행한 후 다음 작업을 진행하고자 할 때 callback 함수를 이용할 수 있다.

      callback을 이용하는 경우 2가지 문제점이 발생할 수 있음.

      - 가독성이 떨어질 수 있음 - callback 안에서 다시 비동기 작업을 하는 경우 callback 안에 callback이 계속 만들어지는 상황이 발생 - callback 지옥
      - 예외 처리의 한계 - 콜백 안에서 예외가 발생하면 콜백 외부에서는 처리할 수 없음.

      callback 함수의 단점을 보완하기 위해서 등장한 개념이 Promise

      ```jsx
      const promise = new Promise((resolve, reject) => {
      	비동기 작업을 수행

      	if(비동기 작업 수행에 성공했다면) {
      		resolve;
      	} else {
      			reject;
      		}
      });
      ```

      chainning(연쇄적으로 동작) 가능

      then과 catch를 연속해서 작성하는 구조

      ```jsx
      Promise
      	.then(수행할 작업)
      	.then(수행할 작업)
      	...
      	.catch(에러가 발생했을 때 수행할 작업)

      // then의 개수는 무제한이지만 catch는 1번만 나와야 한다.
      // 앞에서 수행한 작업의 리턴되는 데이터가 다음 수행할 작업의 함수 매개변수로 전달된다.
      ```

   5. async/await

      가장 최근에 등장한 콜백 처리 방식으로 가독성을 높일 목적으로 추가

      Promise를 조금 더 간결하게 작성하기 위해서 등장.

      ```jsx
      async function 함수이름() {
      	변수 = await 비동기로 동작할 코드
      	비동기 코드가 작업을 완료하면 수행할 코드
      }

      // async와 await은 반드시 쌍으로 등장해야 한다.
      ```

2. **데이터 표현 방법**

   서로 다른 방식의 컴퓨터에서 데이터를 주고 받으려면 표준적인 포맷이 있어야 한다.

   Parsing: 가져온 데이터를 해석하는 과정.

   서버 입장에서는 이 데이터 표현 방식으로 데이터를 만들어서 제공하는 것이 중요하고 클라이언트 입장에서는 이 데이터를 파싱해서 출력하는 것이 중요하다.

   DTD: HTML이나 XML은 브라우저가 해석하기도 하고 설정에 이융하는 경우는 설정을 만든 곳에서 해석을 해야하는데 이 해석하는 위치를 DTD라고 한다.)

   1. 텍스트

      일반 문자열

      구분 기호를 가지고 구분할 수 있도록 만든 포맷을 csv라고 한다.

      변하지 않는 데이터를 제공하고자할 때 주로 이용

      용량이 작기 때문

   2. XML

      태그 형식으로 데이터를 표현

      해석을 개발자가 한다는 것이 HTML과 다른 점이다.

      설정이나 데이터 전송에 이용을 한다.

      다른 방식보다 용량이 크고 최근에는 사용 빈도 수가 낮아지고 있는 추세이다.

   3. JSON

      자바스크립트의 데이터 표현법을 이용하는 방식

      XML보다 용량이 작기 때문에 데이터 전송에 많이 이용한다.

   4. YML(YAML - 야믈)

      이메일 데이터 표현 방식으로 가독성이 좋고 용량이 작기 때문에 최근에 설정에 많이 이용한다.

      구글에서 만든 제품이냐 Spring에서는 YML을 설정에 이용하고 있다.

      아직 데이터 전송에는 사용 빈도 수가 낮다.

   5. HTML

      HTML은 데이터를 표현하는 것이 아니고 화면을 만드는 것이다.

      화면에 보여지기는 하지만 Open API를 제공하지 않는 경우에 이 데이터를 가져와서(Scraping) 임의로 해석해서 데이터처럼 사용하는 경우가 있다.

      HTML로 제공하는 경우는 Open API로 제공하는 것이 아니기 때문에 저작권을 반드시 확인하고 사용해야 한다.

3. **Communication**

   최근의 프론트엔드 변화 - 모바일에서 접속을 많이 하고 사용자에서 가까운 쪽에서 많은 것을 할 수 있도록 한다. 모바일은 언제든지 네트워크에 변화가 생겨서 서버와의 연결이 끊어질 수 있다.

   화면 전환은 최소화해야 하고, 이런 이유 때문에 Single Page Application 이다.

   화면 전환을 하지 않는 대신 하나의 화면에 2개 이상의 컨텐츠를 보여줄 수 있어야 한다.

   로컬에 저장해서 출력하는 부분에 대해서도 고민을 해야 한다.

   - `ajax`: 비동기적으로 서버의 데이터를 받아오는 자바스크립트 기술
   - `Fetch API`: ajax의 단점을 보완하기 위해서 등장한 비동기 자바스크립트 기술
     Promise나 async/await을 적용해서 Fetch API를 사용하기 쉽도록 해주는 자바스크립트 라이브러리 중에 `axios` 가 있는데 라이브러리를 사용하기도 함.
   - `Web Push`: 클라이언트의 요청이 없어도 서버에서 클라이언트로 데이터를 전송하는 기술.
   - `Web Socket`: 연결형 서비스

   1. ajax(Asynchronous Javascript XML-eXtensible Markup Language)

      - XML(eXtensible Markup Language)
        HTML은 마크업 형태로 작성을 해서 해석을 브라우저가 한다.
        HTML에서는 태그의 기능이 고정이다.
        XML은 확장 마크업 언어로 태그의 기능을 개발자가 정하는 것이다.
        XML의 목적은 서로 간에 데이터를 교환하기 위해서 만든 포맷이다.
      - ajax
        비동기적으로 xml을 주고받기 위한 자바스크립트 기술이다.
        최근에는 xml 뿐만 아니라 json이나 csv(text)도 데이터 포맷으로 사용된다.
        `최근에는 자바스크립트를 이용해서 비동기적으로 데이터를 받아오는 것을 ajax라고 한다.`
        (XML은 크게 의미가 없다. 뭐든지 받아온다.)
        `자바스크립트에서는 ajax를 XMLHttpRequest라는 객체를 이용해서 구현한다.`
        `ajax는 예전에 나와서 가독성이 떨어지기 때문에 Fetch API가 추가되었다.`
        `HTML5에서는 Server Sent Events(Web Push)와 Web Socket API가 추가되었다.`
        기본적으로 클라이언트와 서버의 통신 방식은 클라이언트가 서버에게 요청을 하면 서버가 응답을 보내는 방식이다.
        - Push는 클라이언트의 요청이 짧아도 서버가 클라이언트에게 전송하는 것이다.
        - HTTP나 HTTPS는 데이터 외에 헤더 정보를 같이 전송하고 한 번 응답이 오면 연결이 끊어진다. 짧은 메시지를 보낼 때 HTTP나 HTTPS를 사용하면 오버헤드가 크다. 상태 유지가 안되기 때문에 쿠키와 세션을 이용해서 상태 유지를 했는데 이 문제를 해결하기 위해서 연결형 서비스이고 오버헤드가 적은 Web Socket이 HTML5에서 추가되었다.
      - 작업 순서
        - XMLHttpRequest 객체 생성
        - 서버에게 보낼 데이터를 준비
        - 서버에게서 응답이 왔을 때 처리할 콜백 함수를 등록하고 그 안에서 처리하는 코드를 작성
        - open 메서드를 호출해서 연결 요청을 준비
        - sent 메서드를 호출해서 요청을 전송
        - XMLHttpRequest의 속성
          - readyState
            상태를 나타내는 속성으로 0이면 객체를 생성한 직후이고 1이면 open()을 호출한 상태이고 2이면 send()를 호출한 상태. 3이면 서버에서 서버에서 응답이 오기 시작한 상태이고 4이면 응답이 완료된 상태
          - status: 서버에서 응답을 보냈을 때 응답의 상태
          - 100번대이면 처리 중
          - 200번대이면 정상 응답
          - 300번대이면 redirect 중(처리는 끝나고 응답을 전송하고 있는 경우)
          - 400번대이면 클라이언트 오류(401- 권한없음, 404 - 요청한 URL을 처리할 수 없음.
          - 500번대이면 서버 오류
        - responseXML : 서버가 XML로 전송한 경우 XML 데이터, XML 파싱을 해서 사용
        - responseText: 서버가 XML 이외의 형식으로 전송한 경우의 문자열, JSON 데이터의 경우 SJON 파싱을 해서 사용
        - XMLHttpRequest 의 메서드
          - abort(): 요청 취소
          - open(요청 방식, 요청 URL, 비동기 전송 여부): 연결 요청 준비
          - send(데이터 전송): 요청 전송
          - setRequestHeadr(인자, 값): 헤더 설정하는 것으로 인증(로그인)에서 중요
          - sendAsBinary(데이터): 요청을 전송하는 것으로 파일을 업로드하고자 할 때 사용
        - XMLHttpRequest의 이벤트
          - abort: 취소할 때
          - error: 에러가 발생했을 때
          - load: 응답이 전부 왔을 때
      - XML 파싱
        RSS(Rich Site Summary)에 많이 이용 - 신문사 등에서 실시간으로 변경되는 데이터를 제공하는 용도로 주로 인용 - 태그 형태로 데이터를 구성

        ```jsx
        // 파싱
        XML데이터 = ajax객체.responseXML;

        // 필요한 태그 추출
        태그들 = XML데이터.getElementsByTagName("태그 이름");

        // 태그를 순회하면서 작업
        for (let i = 0; i < 태그들.length; i++) {
          // 태그 1개 가져오기
          let 태그 = 태그들[i].childNodes[0].nodeValue;
          // 태그 사용 ...
        }
        ```

   2. SOP(Same Origin Policy - 동일 출처 정책)

      동일한 출처에서 불러온 데이터만 사용할 수 있도록 하는 브라우저의 보안 정책

      동일한 도메인(등록된 도메인이 같아야 하는데 포트번호까지를 확인)의 데이터만 가져와서 사용할 수 있도록 한 브라우저의 보안 정책.

      ajax와 Fetch API에는 적용이되고 img, link, script, viedo, audio, ojbect, embed 등에는 적용되지 않음.

      ajax와 Fetch API에서는 동일한 도메인의 데이터만 사용할 수 있다.

      브라우저에서 다른 도메인의 데이터를 ajax와 Fetch API에서 사용하려면 서버에서 `CORS(교차 출처 리소스 공유)` 설정을 하거나 클라이언트 쪽에서 `Proxy(웹에서 데이터를 받아올 수 있는 언어의 프로그래밍을 이용해야 하는데 react나 vue에서는 설정만으로 가능`)를 이용해야 한다.

      - CORS(Cross Origin Resource Sharing): 다른 도메인에서 자원을 사용할 수 있도록 해주는 것.
      - Proxy: 내부에 데이터를 요청하는 형태로 작성을 하지만 Application Server에서 외부로 나가서 데이터를 가져와서 전달해주는 방식.
        - 네트워크 ← fire wall ← 외부 네트워크
        - 네트워크 → proxy → 외부 네트워크

   3. Promise를 이용한 ajax

      콜백을 이용하는 방법보다 가독성이 좋다.

      일반적으로 콜백 안에서 콜백을 호출하는 경우에는 Promise를 사용하는 것이 좋다.

   4. Fetch API

      서버의 데이터를 가져오는 로직을 단순화 한 ajax보다 새로운 API

      요청과 응답 등의 요소를 Javascript에서 접근하고 조작할 수 있는 인터페이스를 제공하는 API

      fetch()라는 전역 함수를 이용해서 네트워크의 리소스를 비동기적으로 가져올 수 있음.

      XMLHttpRequest 대신 사용

      fetch(요청 URL, 옵션)의 형태로 작성하는데 결과는 Promise객체로 리턴되기 때문에 then과 catch를 이용해서 처리(별도의 콜백을 만들지 않아도 된다.)

      ```jsx
      // 일반적인 처리 방식
      fetch(url, {옵션이름: 옵션값, 옵션이름: 옵션값...})
      .then((response) => response.메서드)
      .then((data) => (파싱한 결과를 가지고 수행할 내용))
      .catch((error) => (에러가 발생했을 때 수행할 내용));

      //예시
      fetch("./resources/data2.json")
      .then((response) => response.json())
      .then((data) => alert(data.count))
      .catch((e) => alert(e.message));
      ```

      옵션: https://developer.mozila.org/en-US/docs/Web/API/fetch

      요청에 성공했을 때 전달되는 객체는 Response

      - Response 속성
        - status(상태 코드 값을 담은 정수)
          100 번대: 요청 중
          200 번대: 요청 처리 성공하고 응답을 전송받음
          300 번대: 요청을 처리하고 리다이렉트 중
          400 번대: 클라이언트 오류(401 - 권한 없음, 404 - 요청 URL이 잘못됨)
          500 번대: 서버 오류
        - statusText(상태 코드 메시지)
        - ok(성공여부 판단)
      - Response 메서드
        - arrayBuffer(): 바이트 배열 - blob과 유사
        - blob(): 파일의 내용
        - formData(): 폼의 데이터 - FORM의 형태로 응답하는 경우(가장 사용 안함)
        - json(): JSON 파싱한 결과 - JSON으로 응답하는 경우
        - text(): 결과 데이터 문자열 - 문자열로 응답하는 경우

4. **웹 클라이언트에서 웹 서버에게 데이터를 전송하는 방법**

   1. URL에 포함시키는 방법

      가장 최근에 등장한 방식으로 데이터가 1개일 때 주로 이용

      [Bloter.net](http://Bloter.net) 이나 Tistory의 상세 보기가 대표적

   2. 요청 방식에 따른 데이터 전달
      - GET
        데이터를 요청할 때 사용하는 방식으로 `URL 뒤에 ?를 추가하고 이름=값의 형태`로 데이터를 전송
        이 데이터 부분을 parameter라고 하기도 하고 query string이라고 하기도 한다.
        history에 남기 때문에 보안성이 떨어진다.
        대신 캐싱이 가능해서 재전송이 가능하다.
        조회는 GET을 사용하고 삭제에는 DELETE를 사용한다.
        [https://q-bit.tistory.com/98](https://q-bit.tistory.com/98)
        →
      - POST
        삽입, 갱신을 할 때 사용하는 방식으로 HTTP Body에 데이터를 넣어서 전송하는 방식
        데이터가 body에 포함되어 있기 때문에 보안성이 우수하다.
        데이터의 길이에 제한도 없음.
        그렇지만 캐싱이 안되기 때문에 자동 재전송 기능이 없다.
        최근에는 데이터를 삽입할 때만 사용하고 갱신을 할 때는 PUT 같은 방식을 이용하는 것을 권장한다.
   3. 헤더 설정을 이용해서 데이터를 전달하기도 한다.

      주로 인증 정보를 전송할 때 많이 사용된다.
