## 비동기 처리

1. **비동기 처리**

   1. 동기(Synchronous)와 비동기(Asynchronous)

      동기: 순차적으로 처리. 하나의 처리가 끝나야 다음을 처리하는 형태.

      비동기: 하나의 처리가 끝나기 전에 다른 처리를 할 수 있는 형태.

      시간이 오래 걸리는 작업의 경우 작업을 순차적으로 처리하게 되면 뒤의 작업이 너무 오래 기달려야 하고 동일한 자원을 사용하지 않는 작업을 순서대로 처리하게 되면 자원의 낭비가 발생하게 된다.

      알림을 어떻게 줄 것인가를 고민해야 한다.

      비동기로 동작한 작업이 끝나고 난 후 작업을 어떻게 할 것인가 하는 문제

      Callback 함수 → Promise → async/await

   2. callback

      상태 변화가 생기면 호출되는 함수를 callback function이라고 한다.

      비동기 처리는 언제 작업이 종료될지 알 수 없기 때문에 작업이 종료되면 다른 작업을 수행할 수 있도록 콜백 함수를 등록할 수 있게 해준다.

      ```jsx
      window.addEventListener("load", 함수);
      처리내용;

      // 브라우저가 html파일을 전부 읽어서 메모리에 적재를 하고 나면 함수를 호출한다.
      // 모든 이벤트 처리는 비동기 방식이다.
      // 함수는 load가 끝나면 호출되기 때문에 콜백 함수라고 한다.
      ```

   3. 비동기 처리를 수행해야 하는 경우
      - 입출력 작업
        파일에 읽고 쓰기
        서버에 요청하고 응답을 받는 것 - 느리기 때문
      - 암호화/복호화 작업(애매하다 - 블록체인 때문)
        오랜 시간이 걸리기 때문에 비동기적으로 처리하는 것을 기본으로 한다.
   4. Promise

      비동기 처리를 수행한 후 다음 작업을 진행하고자 할 때 callback 함수를 이용할 수 있다.

      callback을 이용하는 경우 2가지 문제점이 발생할 수 있음.

      - 가독성이 떨어질 수 있음 - callback 안에서 다시 비동기 작업을 하는 경우 callback 안에 callback이 계속 만들어지는 상황이 발생 - callback 지옥
      - 예외 처리의 한계 - 콜백 안에서 예외가 발생하면 콜백 외부에서는 처리할 수 없음.

      callback 함수의 단점을 보완하기 위해서 등장한 개념이 Promise

      ```jsx
      const promise = new Promise((resolve, reject) => {
      	비동기 작업을 수행

      	if(비동기 작업 수행에 성공했다면) {
      		resolve;
      	} else {
      			reject;
      		}
      });
      ```

      chainning(연쇄적으로 동작) 가능

      ```jsx
      Promise
      	.then(수행할 작업)
      	.then(수행할 작업)
      	...
      	.catch(에러가 발생했을 때 수행할 작업)

      // then의 개수는 무제한이지만 catch는 1번만 나와야 한다.
      // 앞에서 수행한 작업의 리턴되는 데이터가 다음 수행할 작업의 함수 매개변수로 전달된다.
      ```

   5. async/await

      가장 최근에 등장한 콜백 처리 방식으로 가독성을 높일 목적으로 추가

      ```jsx
      async function 함수이름() {
      	변수 = await 비동기로 동작할 코드
      	비동기 코드가 작업을 완료하면 수행할 코드
      }

      // async와 await은 반드시 쌍으로 등장해야 한다.
      ```

2. **Communication**

   최근의 프론트엔드 변화 - 모바일에서 접속을 많이 하고 사용자에서 가까운 쪽에서 많은 것을 할 수 있도록 한다. 모바일은 언제든지 네트워크에 변화가 생겨서 서버와의 연결이 끊어질 수 있다.

   화면 전환은 최소화해야 하고, 이런 이유 때문에 Single Page Application 이다.

   화면 전환을 하지 않는 대신 하나의 화면에 2개 이상의 컨텐츠를 보여줄 수 있어야 한다.

   로컬에 저장해서 출력하는 부분에 대해서도 고민을 해야 한다.

   1. ajax(Asynchronous Javascript XML-eXtensible Markup Language)
      - XML(eXtensible Markup Language)
        HTML은 마크업 형태로 작성을 해서 해석을 브라우저가 한다.
        HTML에서는 태그의 기능이 고정이다.
        XML은 확장 마크업 언어로 태그의 기능을 개발자가 정하는 것이다.
        XML의 목적은 서로 간에 데이터를 교환하기 위해서 만든 포맷이다.
      - ajax
        비동기적으로 xml을 주고받기 위한 자바스크립트 기술이다.
        최근에는 xml 뿐만 아니라 json이나 csv(text)도 데이터 포맷으로 사용된다.
        `최근에는 자바스크립트를 이용해서 비동기적으로 데이터를 받아오는 것을 ajax라고 한다.`
        (XML은 크게 의미가 없다. 뭐든지 받아온다.)
        `자바스크립트에서는 ajax를 XMLHttpRequest라는 객체를 이용해서 구현한다.`
        `ajax는 예전에 나와서 가독성이 떨어지기 때문에 Fetch API가 추가되었다.`
        `HTML5에서는 Server Sent Events(Web Push)와 Web Socket API가 추가되었다.`
        기본적으로 클라이언트와 서버의 통신 방식은 클라이언트가 서버에게 요청을 하면 서버가 응답을 보내는 방식이다.
        - Push는 클라이언트의 요청이 짧아도 서버가 클라이언트에게 전송하는 것이다.
        - HTTP나 HTTPS는 데이터 외에 헤더 정보를 같이 전송하고 한 번 응답이 오면 연결이 끊어진다. 짧은 메시지를 보낼 때 HTTP나 HTTPS를 사용하면 오버헤드가 크다. 상태 유지가 안되기 때문에 쿠키와 세션을 이용해서 상태 유지를 했는데 이 문제를 해결하기 위해서 연결형 서비스이고 오버헤드가 적은 Web Socket이 HTML5에서 추가되었다.
   2. 작업 순서
      - XMLHttpRequest 객체 생성
      - 서버에게 보낼 데이터를 준비
      - 서버에게서 응답이 왔을 때 처리할 콜백 함수를 등록하고 그 안에서 처리하는 코드를 작성
      - open 메서드를 호출해서 연결 요청을 준비
      - sent 메서드를 호출해서 요청을 전송
      - XMLHttpRequest의 속성
        - readyState
          상태를 나타내는 속성으로 0이면 객체를 생성한 직후이고 1이면 open()을 호출한 상태이고 2이면 send()를 호출한 상태. 3이면 서버에서 서버에서 응답이 오기 시작한 상태이고 4이면 응답이 완료된 상태
        - status: 서버에서 응답을 보냈을 때 응답의 상태
        - 100번대이면 처리 중
        - 200번대이면 정상 응답
        - 300번대이면 redirect 중(처리는 끝나고 응답을 전송하고 있는 경우)
        - 400번대이면 클라이언트 오류(401- 권한없음, 404 - 요청한 URL을 처리할 수 없음.
        - 500번대이면 서버 오류
      - responseXML : 서버가 XML로 전송한 경우 XML 데이터, XML 파싱을 해서 사용
      - responseText: 서버가 XML 이외의 형식으로 전송한 경우의 문자열, JSON 데이터의 경우 SJON 파싱을 해서 사용
      - XMLHttpRequest 의 메서드
        - abort(): 요청 취소
        - open(요청 방식, 요청 URL, 비동기 전송 여부): 연결 요청 준비
        - send(데이터 전송): 요청 전송
        - setRequestHeadr(인자, 값): 헤더 설정하는 것으로 인증(로그인)에서 중요
        - sendAsBinary(데이터): 요청을 전송하는 것으로 파일을 업로드하고자 할 때 사용
      - XMLHttpRequest의 이벤트
        - abort: 취소할 때
        - error: 에러가 발생했을 때
        - load: 응답이 전부 왔을 때
   3. SOP(Same Origin Policy - 동일 출처 정책)

      동일한 출처에서 불러온 데이터만 사용할 수 있도록 하는 브라우저의 보안 정책

      ajax와 Fetch API에는 적용이되고 img, link, script, viedo, audio, ojbect, embed 등에는 적용되지 않음.

      ajax와 Fetch API에서는 동일한 도메인의 데이터만 사용할 수 있다.

      다른 출처의 데이터를 ajax와 Fetch API에서 사용하려면 서버에서 `CORS(교차 출처 리소스 공유)` 설정을 하거나 클라이언트 쪽에서 `Proxy(웹에서 데이터를 받아올 수 있는 언어의 프로그래밍을 이용해야 하는데 react나 vue에서는 설정만으로 가능`)를 이용해야 한다.

      네트워크 → proxy → 외부 네트워크

      네트워크 ← fire wall ← 외부 네트워크

   4. XML 파싱

      RSS(Rich Site Summary)에 많이 이용 - 신문사 등에서 실시간으로 변경되는 데이터를 제공하는 용도로 주로 인용 - 태그 형태로 데이터를 구성

      ```jsx
      // 파싱
      XML데이터 = ajax객체.responseXML;

      // 필요한 태그 추출
      태그들 = XML데이터.getElementsByTagName("태그 이름");

      // 태그를 순회하면서 작업
      for (let i = 0; i < 태그들.length; i++) {
        // 태그 1개 가져오기
        let 태그 = 태그들[i].childNodes[0].nodeValue;
        // 태그 사용 ...
      }
      ```
