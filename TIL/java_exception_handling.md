# [Java] 예외 처리

1. 오류의 종류

   1. Compile Error: 물리적 오류
      - java 파일을 .class 파일로 만들 때 발생하는 오류
      - 문법 오류
      - IDE를 사용하면 체크 가능
   2. Logiclal Error: 논리적 오류

      알고리즘의 잘못으로 인해서 잘못된 결과가 만들어지는 경우

      black box test(기능 테스트 - 입력을 주고 정확한 출력이 만들어지는지 확인하는 테스트) 과정에서 발견되고 debugging을 이용해서 수정

   3. Exception: 예외

      문법적인 오류는 없어서 컴파일이 되고 빌드도 되서 실행이 되는데 실행 도중 예기치 않은 상황이 발생해서 프로그램이 중단되는 현상

      디버깅을 이용해서 예외 발생 가능한 코드 부분을 수행하거나 예외 처리를 이용해서 예외가 발생해도 정상적인 동작이 수행되도록 해결

   4. Assertion: 단언

      문법적으로 아무런 문제가 없지만 강제로 에외를 발생시켜서 프로그램울 중단시키는 것

      예전에는 별도의 기능으로 제공했지만 최근에는 예외 처리로 수행하는 경우가 많다.

2. **Debugging**

   메모리의 값을 확인하는 법

   방법

   - 출력하는 메서드를 이용해서 확인.
   - IDE가 제공하는 Debugging Tool 이용
   - 테스트를 수행해주는 외부 라이브러리나 테스팅 툴을 이용

3. **Exception**

   1. Exception

      문법적으로 이상이 없어서 컴파일 시점에는 아무런 문제가 되지 않지만 실행 중에 발생하는 예기치 많은 사건으로 인해서 프로그램이 중단되는 현상

   2. 예외 처리

      예외가 발생할 가능성이 있는 코드를 예외 처리 구문으로 묶어서 예외가 발생한 후의 동작을 설정하는 것.

      예외가 발생했을 때 예외 내용을 로깅하거나 예외가 발생했을 경우 정상적인 값으로 변경해서 동작하도록 하거나 예외가 발생한 경우 무시하고 동작하도록 하기 위해서 수행

   3. 예외가 발생하는 코드를 작성

      ```java
      public class ExceptionHandling {
          public static void main(String[] args) {
              int i = 0;
              int j = 0;
              System.out.println(i/j);
          }
      }
      ```

   4. 예외 처리

      기본 형식

      ```java
      try {
      	예외 발생 가능성이 있는 코드
      } catch(예외처리클래스 변수명) {
      	예외가 발생했을 때 수행할 내용
      }...
      finally{
      	예외 발생 여부에 상관없이 수행할 내용
      }
      ```

      catch는 예외 처리 클래스 이름 달리해서 여러 개 작성 가능

      finally는 생략 가능하고 1번만 작성

      예외 처리 블럭은 각각의 블럭으로 메모리 할당이 이루어짐 - try, catch, finally에서 공통으로 사용할 데이터는 try 외부에 생성해야 한다.

   5. 예외 종류
      - 검사 예외
        java는 프로그램 작성 시에 예상할 수 있는 비정상적인 상태를 통지하기 위해서 반드시 검사해야 하는 예외를 가지고 있다.
        io 또는 network, database 관련된 클래스의 메서드를 사용할 때는 예외 처리를 강제한다. 메서드를 호출할 때 예외 처리를 반드시 하도록 한다.
        예외 처리를 하지 않으면 컴파일 오류가 발생한다.
      - 실행 예외(Runtime Exception)
        프로그램을 작성할 떄 처리하지 않아도 되는 예외
   6. java의 예외 처리 클래스

      예외 관련 최상위 - Throwable

      Error와 Exception 클래스가 상속

      Error는 심각한 예외

      Exception은 덜 심각한 예외

   7. Throwable 클래스의 멤버
      - Stirng getMessage(), String getLocalizedMessage()
        예외 인스턴스의 상세 메시지를 문자열로 리턴
      - void printStackTrace()
        예외 인스턴스 및 그 백트레이스를 표준 에러 스트림에 출력한다. 그 뜻은 예외가 발생한 지점까지 호출된 메서드를 역순으로 빨간색으로 출력
   8. 예외를 처리하는 방법
      - 메서드 내에서 처리
      - 메서드를 호출한 지점으로 예외 처리를 양도 - throws
   9. 예외 강제 발생

      ```java
      throw new 예외클래스이름(매개변수 - 메시지)
      ```

      예외를 강제로 발생시키는 이유는 유효성 검사를 위해서인 경우도 있고 사용자 정으 예외 클래스를 이용해서 예외의 내용을 조금 더 자세히 알려주기 위해서 하기도 한다.

   10. 호출하는 메서드에 예외를 처리하도록 하기
       - 메서드의 매개변수 뒤에 `throws 예외처리글래이름 나열` 하면 이 메서드를 호출하는 메서드에서 반드시 예외처리클래스에 해당하는 예외를 처리해야 한다.
       - 하지 않으면 컴파일 에러 발생
       - java 애플리케이션의 main 메서드는 운영체제가 호출하는 메서드이다. main 메서드에서 throws로 예외를 던지면 예외를 처리할 필요가 없어진다. 학습을 할 때 예외처리를 하는 것이 번거로워서 main 메서드에서 예외를 던지는 경우가 있는데 실제 애플리케이션 개발에서는 권장하지 않는다.
   11. 사용자 정의 예외 클래스
       - 예외 클래스를 상속받아서 클래스를 직접 생성해서 사용하는 것
       - 일반 개발 환경에서는 사용 빈도가 적고 프레임워크를 개발하는 경우에는 필수
       - Java의 데이터베이스 연동에서는 모든 예외를 SQLException으로 던지는데 이렇게 되면 예외가 발생했을 때 예외의 내용을 파악하는게 어려워지는데 Spring에서는 SQLException이 발생했을 때 이를 세분화해서 문법의 잘못인 경우에는 SQLSyntaxException으로 예외를 발생시킨다. SQLSyntaxException은 JDK에 없는 확장 클래스이다.
       - Exception 클래스를 상속받아서 메시지를 상위 클래스의 생성자에 대입해서 메시지를 원하는 대로 출력하도록 하는 경우가 많다.
   12. try ~ resource

       ```java
       try(인스턴스 생성) {
       	인스턴스 사용
       }
       ```

       인스턴스를 만들 때 사용된 클래스가 AutoCloseable 인터페이스나 Closeable 인터페이스를 구현한 경우 자원 해제를 직접 할 필요가 없다.

       정상적으로 수행이 되던 그렇지 않던 try(자원 생성) 구문울 이용하게 되면 자원 생성 위치에서 생성한 인스턴스는 예외 발생 여부에 상관없이 자원 해제가 자동으로 이루어진다.

       ```java
       public class ExceptionHandling1 {
           public static void main(String[] args) {

               String message = null;
               // br은 처리가 끝나면 자동으로 close()를 호출
               // jdk 1.7에서 추가된 문법.

               try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in));) {
                   message = br.readLine();
               } catch (IOException e) {
                   e.printStackTrace();
               }
           }
       }
       ```
