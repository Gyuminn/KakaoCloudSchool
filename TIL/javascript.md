# JavaScript

1.  **개요**
    1. 프로그래밍 언어의 실행 방식
       - 소스 코드 전체를 번역해서 빌드를 수행한 후 실행하는 방식 - C & C++, C#, Java 등
       - 줄 단위로 번역하면서 실행하는 방식 - Python, JavaScript 등(아래쪽에 에러가 있더라도 위쪽의 코드는 실행될 수 있다.)
2.  **JavaScript**

    - 웹 페이지의 동적 처리를 향상시키기 위한 목적으로 탄생한 언어 - 넷스케이프 사에서 개발
    - 문법적으로는 Java와 아무런 관련이 없고 Java의 일부 클래스를 가져와서 사용
    - 기본적으로는 `웹 브라우저 내에서만 동작하는 클라이언트 기반의 언어`
    - 컴파일하지 않고 웹 브라우저에 있는 JavaScript Interpreter Engine이 해석해서 실행
    - `유니코드를 사용하고 대소문자를 구별`
    - `동적 바인딩(Dynamic Binding)`: 실행할 때 메모리의 크기가 결정됨. 이름을 만들 때는 메모리 공간 확보를 하지 않고 실제 데이터가 대입될 때 메모리 공간을 확보.
    - `객체 기반 언어`: 클래스를 만들지 않고 바로 객체를 생성해서 사용하는 것이 가능. 최근에는 클래스를 만드는 문법이 추가 - es6, TypeScript
    - `HTML5의 기반 언어`
    - 많은 라이브러리가 존재
      - jquery: 크로스 브라우징을 지원하기 위해 등장
      - express.js, node.js: 애플리케이션 서버를 만들기 위한 라이브러리
      - angular, react, vue: SPA(Single Page Application) 구혀을 위한 라이브러리
      - d3js: 그래프 구현을 위한 라이브러리
      - bootstrap: 반응형 웹 디자인을 쉽게 해주는 라이브러리
      - react-native, ionic: 모바일 앱 개발을 위한 라이브러리
      - electron: pc용 앱 개발
    - M(Mongo DB)E(Express.js)A(Angular.js)N(Node.js), MER(React.js)N : 빠르게 웹 개발
    - 종류
      - ECMA 5 - ES5: 2015년 이전의 자바스크립트
      - ECMA 2015 ~ : ES6부터 시작하는데 매년 발표, ESNext
      - ESNext에 type을 추가한 MS의 TypeScript

3.  **작성**

    1. 외부에 작성해서 불러들이는 방식

    <script src=”자바스크립트 파일의 경로”></src>
    
    자바스크립트 파일의 확장자는 js를 주로 사용
    
    타입스크립트 파일의 확장자는 ts를 주로 사용
    
    react에서 컴포넌트 파일의 확장자를 구별하기 위해서 jsx를 사용


    2. HTML 파일 내부에 스크립트 영역을 만들어서 사용

    <script>내용</script>

    3. 태그 안에 사용

       <tag event=”스크립트 코드” … />

       가독성이 떨어지기 때문에 사용하는 것을 권장하지 않음.

4.  **규칙**

    HTML과 JavaScript는 위에서부터 읽어서 순차적으로 실행. HTML에 작성된 태그들을 JavaScipt에서 사용을 할 때는 메모리에 로드가 되고 난 이후에 사용해야 한다. 태그가 등장한 다음이나 window의 load 이벤트가 발생하고 난 후.

    자바스크립트는 줄 단위로 읽어서 번역하기 때문에 한 번에 실행되어야 하는 코드를 작성해야하는데 한 줄에 2개 이상의 실행문이 올 때는 이를 구분하기 위해서 ;을 구분해야 한다.

    한 줄의 하나만 명령문만 오는 경우는 ;을 하지 않아도 되는데 가독성과 습관 때문에 ;을 하는 것이 일반적이다.

    한 줄 주석은 // 뒤에 작성, 여러 줄 주석은 /_ 내용 _/ 안에 작성.

    <![CDATA[]]> 에서 [] 안에 작성한 내용은 해석하지 말고 하나의 문자열로 판단.

5.  **구성 요소**
    1. Keywords(에약어)

       javascript 에서 의미를 부여한 단어. 의미 변경이 안됨.

       - Control Character(제어 문자): 프로그래밍에서 \ 다음에 영문자 하나를 추가해서 기능을 부여한 문자
         - \n: 줄 바꿈
         - \t: 탭
         - \’: 작은 따옴표
         - \””: 큰 따옴표
         - \\: \
         - \0: null

    2. Identifier

       사용자가 의미를 부여한 단어. Keyword를 사용하면 안되며 숫자로 시작하면 안됨. 특수문자는 \_와 $만 가능하고 중간 공백 안됨.

    3. Data

       - Literal: 사용자가 직접 입력하는 데이터

         - 숫자는 정수와 실수 형태로 작성
         - 문자열은 작은 따옴표나 큰 따옴표 안에 기재
         - Boolean은 true와 false
         - 참조형 데이터로 null이 있음
         - 문자와 문자열을 구분하지 않음

       - Variable: 데이터에 붙인 이름.
         - 일반적인 데이터: 값이나 값들의 모임
         - 함수: 기능을 수행하는 코드의 모임
         - 객체: 데이터나 함수의 모임
6.  **출력**

    1. 브라우저 화면에 출력
       - document.wirte(출력할 내용): 버퍼에 모아서 출력
       - document.writeln(출력할 내용): 바로 바로 출력, 줄바꿈도 해줌 - HTML에서는 태그를 이용해서 줄 바꿈을 하지 얘를 이용하지는 않는다.
    2. 대화 상자에 출력

       alert(출력할 내용)

    3. 디버그 콘솔에 출력

       console.log(출력할 내용): 콘솔에 출력하면 화면에 보이지 않고 브라우저의 console 창이나 IDE의 console 창에 보이게 된다.

7.  **Data의 분류**

    1. Immutable Data(변경 불가능한 데이터 - 여러 곳에서 같이 사용하거나 옵션)와 Mutable Data(변경 가능한 데이터).

    2. Scala Data(1개의 데이터)와 Vector Data(0개 이상의 데이터 - List와 Map)

       이름에는 하나의 데이터만 매핑할 수 있다.

       Scala Data의 경우는 이름이 데이터를 의미하지만 Vector Data 같은 경우는 이름 이외의 별도의 무엇인가가 추가되어야 데이터를 의미한다. `[인덱스] 또는 .이름`

    3. 데이터의 모양에 따른 분류
       - 정형 데이터: 모든 데이터의 모양이 일정 - `class`, `RDBMS`
       - 비정형 데이터: 데이터의 모양이 일정하지 않은 것 - `Map`, `NoSQL`
       - 반정형 데이터: 모양은 일정하지 않은 것처럼 보이지만 정형으로 만들 수 있는 데이터 - `xml`, `json` 등

8.  **변수**
    1. 분류
       - Local Variable(지역 변수) - 자신의 영역(자바스크립트나 자바에서는 { }을 영역으로 간주) 내에서만 사용이 가능
       - Member Variable(멤버 면수) - 누군가(클래스나 인스턴스)에 소속된 변수
       - Global Variable(전역 변수) - 영역 외부에서 선언해서 모든 곳에서 사용이 가능
    2. 선언(생성) 방법

       이름; : 이렇게 만들면 전역 변수

       var(let 또는 const)이름; : 지역 변수나 멤버 변수

       함수 내에서 var 나 let, const 없이 이름을 만들면 함수가 호출된 이후에는 어디서든지 사용할 수 있게 되버린다. var 나 let, const와 함께 만들어지면 자신의 영역 내에서만 사용이 가능하다. 최근에는 var나 let이나 const 없이 이름 만드는 것을 금기시 한다.

    3. 데이터의 참조를 대입

       이름 = 데이터;

       데이터는 리터럴이나 다른 변수 또는 코드 가능

    4. 변수를 선언하면서 대입

       var(let 또는 const) 이름 = 데이터;

       var나 let 또는 const 라는 단어없이 새로운 이름을 만드는 것도 가능

    5. 이름을 만들 때는 기억하기 좋아야 하고 이름만으로 데이터를 예측할 수 있어야 한다.
    6. let
       - var 키워드의 문제점을 해겨랗기 위해 등장. `동일한 scope 안에서 동일한 이름의 let 변수를 선언할 수 없고 사용만 해야함`
       - hoisting이 되지 않음. (hoisting은 이름을 만들기 전에 사용하는 것인데, var는 이게 됨. 에러가 나는게 아니라 undefined가 됨. let은 에러 호출)
       - 동일한 블럭에서 let을 이용해서 두 번 생성하는 것은 안되지만 블록이 다르면 가능하다. 블럭이 변경되거나 새로 만들어지면 이름 공간이 새로 만들어지기 때문.
    7. const
       - 데이터를 변경하지 못하도록할 때 사용하는 키워드
       - 데이터를 변경하지 못한다는 것만 제외하고는 let과 동일
       - 이름이 참조하는 데이터를 변경할 수 없음.
    8. Naming 방법
       - Camel 표기법 - 일반적인 변수와 함수는 소문자로 시작. 2개 이상의 조합이면 두 번째 단어의 시작은 대문자로 시작. 클래스 이름은 대문자로 시작.
       - Snake 표기법 - 상수는 모두 대문자로 표기
       - 헝거리언 표기법 - 이름에 자료형을 표현. 예로 성적을 정수로 저장하는 변수: nScore
         boolean → b, 정수 → n, 문자 → ch, 실수 → f, 문자열 → str
9.  **데이터 타입(Data Type - 자료형)**

    데이터를 어떻게 얼마만큼의 공간에 저장하고 어떻게 읽을 것인가 하는 문제.

    - Number(숫자): 정수와 실수를 2진수로 변환해서 저장. 실수를 가지고 연산을 할 때는 주의해야 한다.
    - String(문자열): “나 ‘ 사이에 문자를 나열하거나 new String(’ 나 “ 사이에 문자 나열). 문자열 내에서 줄 바꿈을 하고자 하는 경우는 \n을 이용하면 된다. 문자열을 다른 데이터와 + 연산을 하면 그 데이터의 toString이라는 메서드를 호출해서 문자열로 변환한 후 결합을 한다.
    - Boolean: true 또는 false. new Boolean(true 또는 false)
    - undefined: 이름은 존재하는데 아직 데이터가 설정되지 않았거나 이름이 존재하지 않는 경우
    - null: 이름은 존재하는데 가리키는 데이터가 없다.

    <aside>
    ▪️ undefined와 null은 ==로 비교하면 동일하다고 결과가 리턴
    데이터의 자료형 확인은 type of 데이터로 확인.

    </aside>

    - 배열(array-list)
      동일한 자료형의 연속적인 모임. 문법적으로는 자료형만 동일하면 되지만 실제로는 비교가 가능한 데이터만 묶어야 한다. 자바스크립트에서는 모든 데이터가 데이터의 참조를 기억하기 때문에 동일한 자료형이라고 할 수 있다.
      `엄밀히 말하면 자바스크립트나 파이썬은 배열이 존재하지 않는다. 양방향 연결 리스트이다.`
      - 생성: var(let 또는 const) 배열이름 = [값을 나열];
                   var(let 또는 const) 배열이름 = new Array(길이);
      - 요소 접근: 배열이름[인덱스]
      - 배열이름.length 는 데이터의 개수를 리턴
      - 배열이름.toString() 은 각 요소의 toString()을 해서 결과를 하나의 문자열로 리턴
        출력하는 메서드에 배열이름을 대입하면 toString을 호출하기 때문에 출력할 때는 toString을 호출하지 않아도 된다. valueOf()나 join(구분 문자열)을 이용해서도 내부 데이터를 확인할 수 있다.
    - 자료형 변환
      문자열을 숫자나 boolean으로 변환할 때는 Number(문자열) 또는 Boolean(문자열)
      다른 종류의 데이터를 문자열로 변경할 때는 toString()을 호출하면 된다.

10. **Operator(연산자)**
    1. 연산자의 개수에 따른 분류
       - Unary(단항) 연산자: 데이터(피연산자)가 1개만 있으면 수행되는 연산자
       - Binary(이항) 연산자: 데이터(피연산자)가 2개 있으면 수행되는 연산자
       - Ternary(삼항) 연산자: 데이터(피연산자)가 3개 있으면 수행되는 연산자
    2. 연산의 결과에 따른 분류
       - 산술 연산: 숫자 자체를 가지고 연산해서 결과를 숫자 형태로 리턴하는 연산자
       - 논리 연산: true와 false 형태로 연산해서 결과를 Boolean 형태로 리턴하는 연산자
    3. 할당 연산자

       왼쪽에는 이름(변수)이 와야 하고 오른쪽에는 데이터(리터럴, 변수나 상수, 계산식, 함수 호출, 함수 생성)가 오면 되는데 오른쪽 데이터의 참조를 왼쪽의 이름이 가리키도록 해주는 연산자

    4. 증감 연산자

       단항 연산자로 정수 변수에만 사용이 가능한 연산자. ++, —. 연산자의 위치가 데이터의 앞도 가능하고 뒤도 가능. 명령문 안에서 사용된다면 앞에 붙은 경우 증감을 먼저하고 명령에 이용하고 뒤에 붙은 경우에는 데이터를 명령에 사용하고 증감시킨다.

    5. 사칙 연산자

       +, -, \*, /, %, \*\*

       특히 % 연산자를 통해서 일정한 패턴을 갖는 작업이나 코드의 유효성을 빠르게 검사하고자 할 때 사용한다.

    6. 비교 연산자
       - > , ≥, <, ≤, : 크기를 비교해서 boolean으로 리턴, 문자열도 가능
       - ==: 같다 인데 자료형은 확인하지 않음.
       - !=: 다르다 인데 자료형은 확인하지 않음.
       - ===: 자료형까지 일치해야만 true
       - !==: 값 또는 타입이 다른 경우 true
    7. 산술(비트) 연산자

       정수 데이터를 가지고 연산을 수행하는데 연산은 비트 단위로 이루어지고 결과는 다시 10진 정수로 리턴을 해주는 연산자

       - ~: 단항 연산자인데 1의 보수를 구해주는 연산자(0 → 1, 1 → 0)
       - &: Bit AND, 2개의 데이터 모두 1일 때만 1, 그 외의 경우는 0(`0하고 AND 연산을 시키면 모두 0이 나오기 때문에 삭제에 사용된다.`)
       - |: Bit OR, 2개의 데이터 모두 0일 때만 0, 그 외의 경우는 1(`0하고 OR을 시키면 자기 자신이 나오기 때문에 복제에 사용된다.`)
       - ^: Bit XOR(eXclusive OR): 2개의 데이터가 같으면 0, 다르면 1
       - > > : 이진수를 오른쪽으로 이동시키는 연산자 - 첫 번째 비트는 이동 대상이 아님
       - > > > : 이진수를 오른쪽으로 이동시키는 연산자 - 첫 번째 비트도 이동 대상이어서 양수의 경우는 >>와 동일하지만 음수의 경우는 >>와 다르게 동작
       - <<: 이진수를 왼쪽으로 이동시키는 연산자

    8. 논리 연산자

       데이터를 Boolean 형태의 하나의 값으로 간주하고 논리 연산을 수행하는 연산자

       - &&(AND): 둘 다 true 일 때만 true
       - ||(OR): 둘 다 false인 경우만 false
       - !(NOT): true이면 false, false이면 true

       - && 연산의 경우는 앞의 데이터가 false면 뒤의 내용은 확인하지 않음.
       - || 연산의 경우는 앞의 데이터가 true면 뒤의 내용은 확인하지 않음.

       - `Boolean 이외의 데이터를 가지고 &&와 || 연산이 가능하다.`
         이 경우는 결과가 Boolean이 아닐 수 있다.
       - `Falsy: false로 간주하는 데이터` : 0, null, NaN(Not a Number), undefined, “”(아무것도 없는 문자열)
       - `Truthy: true로 간주하는 데이터` : Falsy가 아닌 데이터

    9. 복합 할당 연산자

       연산과 할당을 동시에 수행. 왼쪽이 참조하는 데이터와 오른쪽 데이터를 연산자를 이용해서 연산을 수행하고 왼쪽의 변수에 참조를 대입한다.

       - +=, -=, \*=, /=, %, \*\*=, <<=, >>=, >>>=, &=, ^=, |=, &&=, ||=, !=

    10. 문자열 연산자
        - +: 다른 데이터를 문자열로 변환해서 연결을 시켜주는 연산자
        - \*: 숫자로 변환이 가능한 문자열이라면 곱하기를 해서 숫자를 결과로 리턴한다.
    11. 삼항 연산자

        표현식 ? 표현식1: 표현식2

        표현식이 true이면 표현식1이 남고 false면 표현식2가 남는다.

    12. 쉼표 연산자

        연속해서 적용. 두 피연산자를 모두 평가한 후 오른쪽 피연산자의 값을 반환한다.

    13. 널 병합 연산자(Nullish coalescing operator)

        왼쪽의 데이터가 null 또는 undefined일 때 오른쪽 데이터를 반환하고 그렇지 않으면 왼쪽의 데이터를 반환하는 연산자. || 연산자와 유사하지만 조금 다름.

    14. 기타 연산자
        - new: 생성자를 호출해서 인스턴스를 생성하고 인스턴스의 참조를 리턴하는 연산자
        - this: 생성자나 객체 내부의 함수에서 객체 자신을 가리키는 연산자
        - typeof: 데이터의 자료형을 문자열로 반환해주는 연산자
        - delete: 객체의 속성이나 배열의 요소를 삭제하는 연산자. 기존 데이터는 undefined.
        - instance of: 객체가 특정 클래스로부터 만들어졌는지 확인하기 위한 연산자. ‘ 객체명 instance of 클래스명’ 으로 사용하며, 클래스로부터 생성된 것이면 ture, 아니면 false를 반환한다.
        - in: 데이터가 객체나 배열의 요소인지 확인해주는 연산자.
        - void: 표현식을 평가할 때 값을 반환하지 않도록 지정하기 위한 연산자.
    15. 연산자 우선 순위
        1. , 이나 [인덱스]: 요소 접근
        2. ( ), new
        3. !, ++, --, typeof, void, delete, +, -
        4. %, \*, /
        5. +, -
        6. > > , >>>, <<
        7. <, <=, >, >=
        8. ==, ===, !=, !==
        9. &, ^, | (순서대로)
        10. &&, || (순서대로)
        11. ? :
        12. =, +=, -=, \*=, /=, %=
        13. ,
11. **제어문(Control Statement)**
    1. 분기문: 조건이나 값에 따라 다른 문장을 수행하는 것

       if, switch

       ```jsx
       if(표현식) {
       	표현식이 Truthy일 때 수행하는 내용
       }
       else if(앞의 표현이 Falsy일 때 다시 평가할 표현식) {
       	앞의 표현식이 Falsy이고 현재 표현식이 Truthy일 때 수행할 내용
       }
       else {
       	앞의 모든 표현식이 Falsy일 때 수행할 내용
       }

       // if와 else if, 그리고 else는 별도의 블럭으로 처리
       // 위의 표현식이 true라면 아래 표현식은 확인하지 않는다.

       switch(표현식) {
       	case 값1:
       		표현식의 결과가 값1일 때 수행할 내용
       		break;
       	case 값2:
       		표현식의 결과가 값2일 때 수행할 내용
       		break;
       	default:
       		일치하는 값이 없을 때 수행할 내용
       		break;
       }

       /*
       표현식의 결과는 문자열이나 정수 또는 Boolean 이어야 한다.
       값의 자리에는 반드시 값을 기재하는 것이 아니라 표현식도 가능하다.
       case문의 개수는 여러 개 가능하지만 생략은 안됨.
       default는 생략하거나 1번만 작성
       break가 없으면 break를 만날 때까지 모든 내용을 수행한다.(fall through)

       switch(true)로 작성하고 case문에 Boolean 표현식을 작성하는 것도 가능하다.
       switch문은 전체가 하나의 블럭(switch 기준 블록 스코프)이기 때문에 case문 안에서
       변수를 생성하면 밑의 case문에서 사용할 수 없다.(case는 별도의 스코프를 가지지 않는다.)
       */
       ```

    2. 반목문(Loop)

       for, while, do ~ while, for ~ in

       ```jsx
       for(처음 한 번 수행되는 식; 판별식; 두 번째 수행되는 식) {
       	반복할 내용;
       }
       /*
       처음 한 번 수행되는 식을 수행하고 판별식을 확인해서 falthy가 아니면 반복할 내용을 수행하고
       이 후 부터는 두 번째 수행되는 식을 수행하고 판별식을 확인해서 falth가 아니면
       반복할 내요을 수행한다. 판별식이 falsy가 되면 반복 내용을 종료.
       */

       while(표현식) {
       	수행할 내용
       }
       /*
       표현식이 truthy라면 { } 안의 내용을 수행하고 다시 표현식으로 돌아와서
       Falsy가 될 때까지 반복
       */

       do{
       	수행할 내용
       } while(표현식);
       /* 표현식이 뒤에 있어서 어떤 상황 속에서도 수행할 내용은 한 번은 실행한다.
       기능 적으로는 while과 동일한데 반드시 한 번은 한다는 의미 전달을 위해 사용한다.
       */

       for(임시변수 in 객체나 배열) {
       	수행할 내용
       }
       /*
       객체의 경우는 속성 이름을 임시 변수에 순서대로 대입
       배열의 경우에는 각 요소의 인덱스를 임시 변수에 대입
       */
       ```

    3. 제어문 작성 규칙
       - switch를 제외한 제어문에서 수행해야 할 내용이 한 줄이라면 { }는 생략이 가능.
       - 제어문 안에 제어문 사용이 가능. 안쪽 제어문에서는 바깥쪽 제어문의 데이터를 사용하는 것이 가능.
    4. 기타 제어문
       - break: switch나 반복문에서 switch나 반목문의 수행을 종료하기 위한 명령어
       - continue: 반복문에서 아래 내용을 수행하지 않고 다음 반복으로 진행하기 위한 명령어
       - return: 함수의 수행을 종료하고 0개 또는 하나의 데이터를 가지고 호출한 곳으로 돌아가도록 해주는 명령어
12. **Function**
    1. 개념

       한 번에 수행해야 할 코드를 하나의 이름으로 묶어두고 사용하는 것으로 독립적으로 메모리를 할당받아서 수행됨.

    2. 목적
       - 중복되는 코드를 방지하기 위해서
       - 모듈화 - 코드를 읽기 좋고 실행하기 편리하도록 분할
    3. 종류
       - Maker Function: 언어 차원에서 제공하는 함수로 JavaScript에서는 window 객체가 제공
       - User Define Function: 개발자가 필요에 의해서 생성한 것.
       - 3rd party Function: 다른 개발자가 만든 함수. 이 함수를 사용할 때는 주의해야 한다. 보안이나 라이센스 문제를 생각해야 한다.
    4. `자바스크립트에서 함수는 일급 객체`
       - 함수도 하나의 자료형
       - 변수에 대입할 수 있고 리턴할 수도 있음.
    5. 함수를 선언: 함수를 만드는 것.

       ```jsx
       // 예전 방식
       function 함수이름(매개변수 나열) {
       	수행할 내용
       	return 데이터; // 없는 경우도 있음
       }

       // 변수에 대입하는 방식
       (var|let|const) 이름 = function(매개변수 나열) {
       	수행할 내용
       	return 데이터; // 없는 경우도 있음.
       }

       // 화살표 함수
       (var|let|const) 이름 = (매개변수 나열) => {
       	수행할 내용
       	return 데이터; // 없는 경우도 있음.
       }
       ```

    6. 함수를 호출(실행)
       - 직접 호출: 함수 이름(매개변수 대입)
       - 콜백(상태 변화나 이벤트가 발생하면 호출)으로 지정해서 호출: 특정 이벤트가 발생하면 자동으로 함수를 실행하도록 해주는 것
    7. 함수의 구성
       - 이름: 함수를 구별하기 위한 이름. 이름은 자기 영역에서 중복되면 안됨. 중복되면 이전 내용이 사라짐.
       - 매개변수(parameter, argument, 인자, 인수): 함수를 호출할 때 넘겨주는 데이터
       - return: 함수의 코드를 실행하고 호출한 곳에 넘겨주는 데이터 - 결과
