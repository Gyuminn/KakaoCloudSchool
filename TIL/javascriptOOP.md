## Javascript의 OOP

ES5까지는 클래스의 개념이 없어서 OOP의 개념이 아님 - 객체 기반 언어. ECMA 2015에서 클래스의 개념이 도입됨.

1. **객체 지향의 3대 특징**
   1. `Encapsulation(캡슐화)`

      불필요한 부분을 숨기고 하나로 만드는 것. 클래스를 만드는 것과 인스턴스 만드는 것 그리고 접근 지정자를 학습.

   2. `Inheritance(상속)`

      하위 클래스가 상위 클래스의 모든 것을 물려 받는 것.

   3. `Polymorphism(다형성)`

      동일한 메시지에 대하여 다르게 반응하는 성질.

      동일한 코드가 호출하는 객체에 따라 다른 메서드를 호출하는 성질.

      상속과 오버라이딩(가끔은 오버라이딩이 아니라 구현)으로 구현됨.
2. **객체(Object)**

   데이터를 저장할 수 있는 속성(variable - property)과 기능을 수행하는 메서드(function - method)를 모아놓은 것.

   1. `사용자 정의 객체`: 개발자가 필요에 의해서 생성
      - 생성
        ```jsx
        // 첫 번째 방법
        let 이름 = {
        	"속성이름": 데이터,
        	"메서드이름": 메서드 코드...
        }

        // 두 번째 방법
        let 이름 = new 생성자(매개변수 나열)
        ```
      - 내부 요소 호출(.을 이용)
        ```jsx
        이름.속성이름;
        이름.메서드이름(매개변수);

        // Javascript는 독특하게 대괄효 표기법으로 가능하다.
        // 이 때는 문자열 형태로 입력해야 함.
        let obj = {
          name: "adam",
        };
        obj.name;
        obj["name"];
        ```
      - 내부 속성은 중복해서 만들어지지 않기 때문에 동일한 이름에 2번 삽입하면 이전 내용이 없어지고 새로운 내용으로 변경된다.
      - for(임시변수 in 객체) { }
        객체의 모든 속성의 이름을 임시변수에 문자열 형태로 대입하고 { } 안의 내용을 반복 수행
      - 속성이름 in 객체
        속성이 객체에 존재하는지 여부를 판단하여 Boolean으로 return
      - with(객체) { }
        이 안에서는 객체 이름을 생략해도 됨.
      - 객체.속성이름 = 데이터 또는 함수;
        속성 추가 및 수정. 존재하는 속성이면 수정이고 존재하지 않는 속성이면 추가.
      - delete(객체.속성이름)
        속성 삭제
      - `this`
        객체 안에 존재하는 메서드에 존재하는 숨겨진 매개변수.
        객체 안에 만들어진 메서드에서는 this라는 변수를 사용할 수 있는데 이 this는 객체를 참조한다.
        객체 안에 만들어진 메서드에서 객체의 속성을 이용할 때는 ‘this.속성이름’의 형태로 사용해야 한다. this를 붙이지 않으면 메서드 안에서 이름을 찾게 된다.
        화살표 함수에서는 this를 사용할 수 없다.
      - `constructor(생성자)`
        생성자는 객체를 생성해서 메모리 할당을 하고 그 참조를 리턴하는 함수
        일반 함수를 만드는 것과 동일한 방법으로 만다는데 객체를 생성하고자 하면 내부에서 this를 이용해서 필요한 속성과 메서드를 정의하면 된다.
        ```jsx
        // 생성자 호출
        new 생성자이름(매개변수);

        // 생성자(클래스)를 만드는 이유는 동일한 속성을 갖는 객체를
        // 여러 개 생성해야 하는 경우이다.
        ```
   2. `내장 객체`: JavaScript에서 제공하는 객체 - API(Application Programming Interface) 나 SDK(Software Development Kit) 라고도 함.
   3. `3rd Party 객체`: 다른 개발자나 회사가 제공(Library, Framework: Solution)

3. **클래스(class)**

   유사한 모양의 객체를 만들기 위한 템플릿

   생성자를 이용해서도 생성이 가능하지만 생성자를 이용하게 되면 모든 멤버를 생성자 안에서 만들어야 하기 때문에 객체가 가져야 하는 메서드가 많아지면 코드가 가독성이 떨어지게 된다 → `ECMA2015(ES6) 에서 class 문법을 추가시킴.`

   1. 선언(클래스 이름은 일반적으로 첫 글자를 대문자로 짓는다.)

      ```jsx
      // 기본적인 방법
      class 클래스이름 {
        클래스내용;
      }

      // 상속을 받는 경우
      class 클래스이름 extends 상위클래스이름 {
        클래스내용;
      }

      // 표현식을 이용
      let 이름 = class {
        클래스내용;
      };

      let 이름 = class 내부에서사용할이름 {
        클래스내용;
      };
      ```

   2. 클래스를 이용한 `객체 생성`

      클래스를 이용해서 생성된 객체를 `Instance`라고 한다.

      클래스의 생성자는 클래스 이름과 동일하게 만들어지기 때문에 생성자이름 대신 클래스 이름을 기재해도 된다.

      ```jsx
      // 엄밀히 말하면 '이름'이 아니라 'new 생성자이름'이 instance이다.
      let 이름 = new 생성자이름(매개변수);

      // new 연산자는 생성자를 호출해서 인스턴스를 heap 영역에 만들고
      // 그 참조를 return하는 연산자이다.
      ```

   3. 클래스 안에 멤버 속성 만들기

      메서드 안에서 this와 함께 이름을 만들면 인스턴스의 속성이 된다.

   4. `Javascript에서의 class는 정적이지 않다.`

      Javascript에서는 class의 내용을 수정할 수 있다. 편의를 위해서 문법적으로 추가한 것이지 다른 언어에서의 class가 정적인 것과는 다르게 동적이다.

      `Class가 prototype이라는 내부 객체를 이용해서 모든 속성을 저장한다.`

      prototype이 객체라서 확장이 가능하다.

      클래스를 선언할 때는 없었는데 나중에 추가하거나 변경하고자 하면 다음과 같다.

      ```jsx
      클래스이름.prototype.속성이름 = 내용;
      ```

   5. 이름
      - Javascript에서는 변수, 함수, class가 모두 동일한 레벨이다.
      - 즉, 값이나 함수나 클래스나 객체 모두 동일한 데이터로 취급. 하나의 이름에 한 가지만 저장이 가능하기 때문에 중복 정의(Overloading)가 안됨.
      - 기존의 이름에 값이 저장되어 있는데 함수를 대입하면 기존의 값은 사라지고 함수의 내용이 저장된다.
   6. `Constructor(생성자)`
      - 인스턴스를 생성하고 그 참조를 리턴하는 특별한 목적의 메서드
      - 메서드에서 ‘this.속성이름’을 이용해서 인스턴스의 속성을 생성할 수 있다.
      - 일반 메서드에서 속성을 생성하는 경우 메서드 호출을 하지 않으면 속성을 사용할 수가 없다.
      - 생성자는 인스턴스를 생성하기 위해 호출하는 메서드이기 때문에 메서드를 만들려면 반드시 한 번은 호출해야 한다. 생성자에서 필요한 속성을 만들면 속성을 만들기 위해서 다른 메서드를 호출하는 번거로움을 없앨 수 있다. javascript에서는 constructor 라는 속성에 생성자를 만들어서 대입할 수 있다.
      - 생성자는 1개만 만들 수 있는데 기본적으로 매개변수가 없고 아무일도 하지 않는 생성자가 1개 제공된다.
      - 생성자를 직접 만들면 제공되는 생성자는 소멸된다.
      - 생성자를 호출하는 방법은 ‘new 생성자이름{매개변수 나열}’. 실제로는 `클래스이름.prototype.constructor` 가 호출된다.
   7. `getter & setter` - 접근자 메서드
      - 인스턴스 안에 존재하는 속성의 데이터를 변경하고 리턴하는 메서드
      - getter는 속성의 데이터를 리턴하는 메서드
        일반적으로 매개변수는 없고 속성의 데이터만 리턴한다.
        이름은 ‘get속성이름’ 으로 만드는데 속성 이름의 첫 글자는 대문자로 표기한다. - camel표기법.
        Boolean인 경우는 get 대신에 is를 사용하기도 한다.
      - setter는 속성의 데이터를 설정하는 메서드
        매개변수는 1개(데이터 전체) 또는 2개(배열이나 객체의 일부 속성을 변경하는 경우 인덱스나 속성 이름을 매개변수로 추가하는 경우가 있다.)로 하는 것이 일반적이면 리턴을 하지 않는다.
        이름은 ‘set속성이름’으로 만든다.
      - Javascript에서는 getter앞에 get을, setter앞에 set을 추가하면 데이터를 저장하는 속성처럼 사용하는 것이 가능하다. 개발자들은 이 분법을 잘 사용하지 않는다.
   8. `static`
      - 메서드 앞에 static을 붙이면 인스턴스가 아니라 클래스가 호출할 수 있는 속성이 된다.
      - static이 붙으면 인스턴스가 호출할 수 없음.
      - 인스턴스의 메서드 안에서 static 메서드 호출하는 것은 가능하지만 반대로는 되지 않음.
      - 클래스가 만들어지고 인스턴스가 생성되기 때문에 인스턴스 메서드를 호출하는 시점에는 클래스의 내용이 완성된 상태이다. 그렇지만 클래스의 메서드를 호출하는 시점에는 인스턴스가 만들어져 있을 수도 있고 없을 수도 있기 때문에 클래스의 메서드에서 인스턴스의 메서드를 호출하는 것은 안된다.

4. **Inheritance(상속)**
   1. 개념
      - 상위 클래스의 모든 것을 하위 클래스가 물려받는 것.
      - 기본적으로는 클래스들을 만들다가 중복되는 내용이 나오면 중복되는 내용을 가지고 상위 클래스를 만들고 다른 클래스들에서 상속을 하는 형태를 취하게 된다.
      - 화살표의 방향을 위에서 아래로가 아니라 아래에서 위로 그린다.
      - 객체 지향에서는 상속이라 하지 않고 ‘is a’ 라고 한다.
      - 하나의 클래스 안에 다른 클래스의 인스턴스가 포함되는 경우는 ‘has a’라고 한다.
   2. 상속받는 방법

      클래스 선언 뒤에 ‘extends 상위클래스이름’

   3. super
      - 하위 클래스에서 상위 클래스의 속성을 호출할 때 상위 클래스 인스턴스를 super라고 한다.
      - 하위 클래스의 일반 메서드에서 상위 클래스에 만들어진 메서드를 호출하고자 할 때는 ‘super.메서드이름()’의 형태로 호출한다.
      - constructor 안에서 상위 클래스의 constructor를 호출하고자 하는 경우는 super()로 호출한다.
   4. method overriding(재정의)
      - 상위 클래스의 메서드와 동일한 모양의 메서드를 하위 클래스에서 다시 정의하는 것
      - 목적은 기능 확장
      - 상위 클래스의 메서드를 가지고 그대로 사용하는 것이 부족해서 추가하기 위해서이다.
      - 새로운 기능을 만들거라면 overriding을 하면 안된다.
      - `메서드의 기능이 생성하는 거라면 상위 클래스의 것을 먼저 호출해야하고 정리하는 것이라면 상위 클래스의 것을 나중에 호출해야 한다.`
      - 최근의 언어에서는 내용이 없는 메서드에 내용을 채우는 것을 overriding이라고 하지 않는다.
5. **Iteration**
   1. 개념
      - 순차적 처리를 위한 것.
      - 모든 데이터가 순차적 처리를 할 수 있는 것은 아니고 Javascript에서는 Iterable 프로토콜과 Iterator 프로토콜을 준수해야만 순차적 처리가 가능하다.
      - 순차적 처리가 가능한 대표적인 데이터가 Array(배열)
      - 순차적 처리가 가능한 데이터에는 Symbol.iterator가 존재해야 한다.
      - Symbol.iterator 속성을 추출해서 next 메서드를 호출하면 순차적으로 가능하다.
      - 직접 만들고자 할 때는 Generator와 Symbol 내장 객체를 이용해야 한다.
   2. for - of
      - for - in 은 객체나 배열의 모든 속성을 순차적으로 접근하기 위한 명령문
      - for - of 는 순차적 처리가 가능한 데이터를 순회하는 명령문.
      - Javascript에서는 for - in 보다는 for - of 를 쓰는 경우가 많다.
6. **Destructuring - 구조 분해 할당 또는 비구조화 할당**
   1. 개념
      - 데이터를 나누어서 저장
      - 다른 언어에서는 Tuple이라고 한다.
   2. 배열
      - 순서대로 할당되고 마지막 변수에는 이전에 할당한 것들을 제외한 모든 것들이 할당된다.
   3. 인스턴스
      - 변수의 이름과 속성의 이름을 맞추어서 할당이 된다.
   4. spread연산 & rest param
      - `구조 분해 할당을 할 때 나머지를 전부 할당하는 연산을 spread 연산`
      - `파라미터에 적용하면 rest param`이라고 함.
      - 할당할 변수 앞에 … 을 붙여주면 된다.
   5. 기본값을 설정해서 구조 분해 할당 가능
7. **Exception Handling(예외 처리)**
   1. 용어
      - 물리적 에러: 잘못된 문법으로 프로그램이 실행되지 않는 상황
      - 논리적 에러: 문법은 맞게 작성했는데 알고리즘을 틀리게 설계해서 잘못된 결과가 도출.
      - exception(예외): 문법에는 맞아서 번역은 되는데 특수한 상황이 발생해서 프로그램이 중단되는 현상.
      - assertion(단언): 에러가 없고 예외가 발생하는 상황이 아니지만 개발자가 강제로 예외를 발생시켜 프로그램을 중단하는 것.
      - Debugging: 코드를 작게 쪼개서 실행시키면서 논리적 에러나 예외 발생 지점을 찾아내는 것.
      - Test: 예전에는 테스트를 개발이 종료되고 난 후 하는 경우가 많았는데 최근에는 개발 과정에 테스트를 하기도 한다. 이를 TDD(테스트 주도 개발)라고 한다.
   2. 예외 처리

      예외가 발생했을 때 어떻게 할 것인가를 작성하는 것.

      목적은 예외가 발생하더라도 계속해서 프로그램을 실행시키기 위해서이며 또한 예외를 로깅(기록)하기 위해서이다.

   3. 예외 처리 기본 구조

      ```jsx
      try {
      	예외 발생 가능성이 있는 코드
      } catch (예외처리 변수) {
      	예외가 발생했을 때 수행할 코드
      } finally {
      	예외 발생 여부에 상관없이 수행할 코드
      }

      // finally는 생략이 가능
      // 예외가 발생하면 예외 객체가 예외처리 변수에 자동으로 대입된다.
      // 언어에 따라서는 catch를 여러 개 만들 수 있는 것도 있고
      // catch를 생략하고 finally만 적어도 되는 경우각 있다.
      // Javascript는 catch를 1개만 작성할 수 있고 catch 대신 finally를 사용할 수 있음.
      // finally에는 대부분의 경우 정리 작업을 수행하는 코드를 작성한다.
      ```

   4. 예외 객체

      예외가 발생했을 때 catch에 전달되는 객체

      - message: 예외 발생 이유
      - description: 예외 설명
      - name: 예외 이름

   5. 강제로 예외 발생
      - throw 예외메시지
      - throw new Error(예외 메시지)
8. **Module Programming**

   프로그램을 분할해서 작성하는 것.

   일반적인 언어에서는 클래스 단위로 분할하는 것이 일반적이나 함수 단위로 분할하는 경우도 있다.

   화면 단위로 분할하기도 한다.

   1. export

      - 현재 모듈의 내용을 내보내서 외부에서 사용할 수 있도록 해주는 기능.
      - export 데이터 형태로 내보냄.
      - export default 데이터 형태로 내보낼 수 있는데 이 경우는 명시적으로 1개만 내보내고자 할 때 사용한다. 이 코드는 하나의 모듈에 번만 작성되어야 한다.

      ```jsx
      // 각자 내보내기
      export 내보내고자 하는 데이터(값, 함수, 클래스) 나열

      // 여러 개를 묶어서 내보내기
      export {내보내고자 하는 데이터 나열...}

      // 이름을 변경해서 내보내기
      export {원래이름 as 다른이름...}

      // 구조 분해 할당을 이용해서 내보내기 (배열인 경우는 거의 없다. 가능은 함.)
      export {이름 나열} = 객체나 배열

      // 1개만 내보내고자 하는 경우
      export default 데이터
      ```

   2. import

      - 다른 모듈에서 export한 내용을 가져와서 사용하기 위한 명령어

      ```jsx
      // default로 내보낸 데이터를 가져오기
      import 이름 from "모듈이름";

      // 내보낸 모든 데이터를 하나의 이름으로 가져오기
      import * as 이름 from "모듈이름";

      // 내보낸 데이터 중 일부분만 가져오기
      // 모듈에서 이름에 해당하는 것만 가져와서 사용
      // 여러 개를 가져오고자 하면 , 로 구분해서 이름을 나열하면 된다.
      import { 이름 } from "모듈이름";

      // 이름을 변경해서 사용하고자 할 때
      import { 이름 as 다른이름 } from "모듈이름";
      ```
