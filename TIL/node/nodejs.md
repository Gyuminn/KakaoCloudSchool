# [Node.js]

1. **개요**

   애플리케이션을 개발을 위한 자바스크립트 프레임워크 또는 라이브러리

   논드 만으로 애플리케이션 개발을 하기도 하지만 다른 자바스크립트 라이브러리의 기반 프레임워크가 되기도 함.

   원래 자바스크립트는 브라우저 내에서 동적인 작업을 처리하기 위한 언어

   `실제 내부 코드는 C++로 되어 있음`

   1. 장점

      자바스크립트 엔진을 사용하기 때문에 접근이 쉬움 - learning curve가 짧다.

      비동기 방식이므로 리소스 사용량이 적음

      다양한 라이브러리가 제공

   2. 단점

      Native 언어로 만든 서버 환경보다는 느릴 수 있음.

      짧은 시간에 대량의 클라이언트 요청을 대응하는 웹 애플리케이션 개발에 적합하고 대량의 데이터를 긴 처리 시간을 요구하는 작업에는 부적합

      대용량 연산 작업을 할 때는 직접 구현하지 않고 AWS의 Lambda나 Google Cloud Functions 같은 서비스를 이용하면 어느 정도 해결됨.

   3. 웹 서버 이외의 노드

      SPA(Single Page Application): Angular, React, Vue 등

      모바일 앱 프레임워크: React Native

      데스크탑 애플리케이션: Electron(Atom, slack, VSCode, 블록 체인 애플리케이션 등)

   4. 외부 라이브러리를 활용

      npm이라는 프로그램을 이용

      npm을 이용하면 기능을 확장한 수많은 모듈을 쉽게 다운로드하고 설치할 수 있다.

      최근에는 npm 대신에 yarn을 사용하는 경우도 많다.

2. **Node 설치**

   1. 버전
      - LTS: 안정화된 버전으로 짝수
      - Current: 현재 개발 중인 버전
   2. 설치

      Windows는 [https://nodejs.org에서](https://nodejs.org에서) 다운로드 받아서 설치

      Mac은 다운로드 받아서 설치해도 되고 brew install node로 설치 가능

   3. 설치 확인

      node -v

      npm -v

3. **Node 프로젝트 만들기**

   빈 디렉토리에서 npm init 이라는 명령어로 생성하고 옵션을 설정.

   윈도우에서 이 명령어가 잘 안되는 경우에는 터미널에서 npm init을 해도 되고 VSCode의 터미널이 PowerShell 이어서 안되는 경우도 있으므로 이 경우 [File] - [Preference] - [Settings]에 가서 default profile windows를 검색한 후 command prompt로 변경하고 VSCode 종료 후 재실행

   ```jsx
   cd는 디렉토리를 변경하는 명령어
   cd 디렉토리 이름을 입력하면 디렉토리로 프롬프트를 이동
   cd ..을 입력하면 상위 디렉토리로 이동.
   ```

   1. 옵션 설정
      - `package name: 패키지를 배포할 때 사용할 이름인데 디렉토리 이름과 같으면 안됨. 배포가 되지 않는다.`
      - version: 버전
      - description: 앱에 대한 설명
      - entry point: 시작하는 파일 이름(앱의 출발점으로 index.js나 App.js를 많이 이용)
      - test command: 앱을 테스트할 때 사용할 명령어 이름
      - git repository: git 과 연동할 때 사용할 URL
      - keywords: 패키지가 배포된 경우 사용할 검색어
      - author: 제작자
      - license: ISC나 MIT를 적는데 오픈 소스라는 의미
   2. 프로젝트 실행
      - `node start` 하게 되면 package.json 파일에 설정한 entry point로 지정한 파일이 실행
      - `node 파일명` 을 하게되면 파일이 실행
   3. console.log

      콘솔에 메시지를 출력하는 함수인데 함수의 결과는 터미널에 출력된다.

4. **모듈 프로그래밍**

   1. Module

      독립적으로 실행가능한 작업의 단위

      노드에서는 하나의 파일이 모듈

      모듈화는 중요한 작업 중의 하나

      하나의 모듈에 모든 내용을 전부 작성하면 가독성이 떨어지고 재사용성이 떨어지게 된다.

      역할 별로 나누는 작업이 중요

      - Controller: 클라이언트의 요청을 받아서 필요한 서비스 로직을 호출하고 응답을 클라이언트에게 전송하는 역할(문지기 같은 거라고 생각.)
      - Service: 사용자의 로직(비즈니스 로직)을 처리하는 역할
      - Repository(DAO - Data Access Object): 데이터 저장소와 연결해서 작업을 수행하는 역할
      - VO(Variable Object): 여러 개의 속성을 묶어서 하나로 표현하기 위한 역할
      - DTO(Data Transfer Object): 서로 다른 계층 사이에 전달을 위한 역할
      - Entitiy: ORM(객체와 테이블의 행을 매핑시켜주는 프레임워크)에서 테이블과 연결되는 역할

      `VO, DTO, Entity는 도메인(도메인 클래스)라고 하는데 여기는 개발자가 임의로 하지 않는다.`

      - View: 화면을 출력하는 역할

   2. 모듈의 내용을 내보내고 가져와서 사용
      - 내용을 내보낼 파일을 생성하고 module.exports를 이용해 다른 곳에서 사용할 수 있도록 내보낸다.
      - 실행할 파일을 생성하고 필요한 것들을 require을 통해 가져와서 사용한다.
      - { }로 묶어서 내보낸 것은 이름을 맞추어서 받아야 하고, 하나를 내보냈을 때는 이름을 바꿔서 받을 수 있다.

5. **Node 내장 객체**

   node가 제공하는 객체

   1. 노드의 전역 객체

      이 객체는 노드 프로그램 전체에서 1개만 생성

      이 객체는 하나만 만들어서 노드 프로그램 전체가 공유

      사용하는 것을 권장하지는 않지만 모든 곳에서 사용해야 할 데이터가 있는 경우 사용

      예를 들면 현재 접속자 수나 대기자 수 또는 로고 등은 모든 사용자에게 동일하게 보여진다. 이런 데이터를 global을 이용해서 사용한다.

   2. console

      현재 보여지는 터미널 화면

      로직이 복잡해지거나 여러 모듈을 거쳐가면서 수행되는 코드가 있다면 중간에 로그를 출력해서 확인을 하는 것이 좋다.

      로그를 출력하는 작업을 한 것은 배포를 할 때 모두 제거해야 한다.

      필요하다면 로그는 파일이나 데이터베이스에 기록하는 것이 좋다.

      로그를 콘솔에 출력하는 것은 개발 과정에서만 한다.

      - console.log(메시지): 메시지 로깅
      - console.error(메시지): 에러 형태로 로깅
      - console.trace(메시지): 호출 스택 로깅 - 함수나 메서드를 호출하는 순서를 역순으로 출력. 호출하는 메서드의 순서를 확인하고자 할 때 사용.
      - console.table(배열): 테이블 형태로 출력
      - console.time(메시지) & console.timeEnd(메시지): 동일한 메시지를 사용하면 2개 호출 사이의 시간을 출력
      - console.dir(객체, 옵션): 객체를 로깅할 때 옵션을 설정하는 것이 가능.

   3. 경로 관련 속성

      - \_\_filename: 현재 파일의 경로
      - \_\_dirname: 현재 디렉토리의 경로

      최근에 등장하는 언어나 프레임워크에서는 *를 이용해서 예약어를 만드는 경우가 많으므로 이제는 사용자 정의 이름을 만들 때 *로 시작하는 이름을 사용하는 것을 추천하지 않는다.

   4. module.exports

      모듈의 내용을 다른 곳에서 사용할 수 있도록 하고자 할 때 사용하는 속성

      ```jsx
      module.exports = 내보낼 내용

      // 아래와 같이 해도 된다.
      exports.내보내고자 하는 이름 = 내용
      ```

   5. this

      함수나 클래스 외부에서는 module.exports가 된다.

      함수 안에서는 global이다.

      클래스의 메서드 안에서는 클래스의 인스턴스가 된다.

   6. require 함수

      외부 모듈의 내용을 가져올 때 사용하는 함수

      import도 외부 모듈을 가져오는데 사용할 수 있지만 require는 caching을 한다.

      한 번 사용한 모듈을 메모리에 적재해 두었다가 다음에 require를 하게되면 caching된 모듈을 가져온다.

      .js는 생략 가능

   7. process 객체

      노드 프로세스에 대한 정보를 가지는 객체

      노드 버전이나 CPU 사용량 등을 확인할 수 있는 속성과 메서드를 제공

      - process.nextTick(콜백 함수): 다른 콜백 함수보다 우선해서 처리. Promise.resolve().then()으로 작성 가능
      - process.exit(코드): 노드 프로세스 종료(서버에서는 사용하지 않는 것이 일반적). 코드는 운영체제에게 알려주는 종료 이유

   8. os 객체

      운영체제에 대한 정보를 가진 객체

      운영체제에 대한 종류나 CPU 또는 메모리 사용량 등을 확인할 수 있는 속성과 메서드를 제공

      실제 서비스를 운영할 때는 메모리 사용량을 확인해보는 것이 좋다.

      서버를 운영할 때 메모리 사용량을 주기적으로 모니터링해서 서버를 물리적으로 늘릴 것인지 여부를 판단

   9. `path 객체`

      디렉토리와 파일의 경로를 쉽게 조작하도록 도와주는 모듈

      속성과 함수

      - path.sep
        경로 구분자(windows는 ₩이고 나머지는 /). 서버를 만들 떄는 운영체제를 확정짓고 만들기 때문에 잘 사용하지 않지만 일반 애플리케이션을 만들 때는 경로 지정 시 이 속성을 이용해서 지정해야 윈도우나 Mac에서 코드 수정없이 동작하는 애플리케이션을 만들 수 있다. os 모듈을 이용해서 운영체제를 확인해서 별도로 코딩을 하는 방법도 있다.
      - path.dirname(경로)
        경로에 해당하는 파일이 위치하는 디렉토리
      - path.extname(경로)
        경로에 해당하는 파일의 확장자
      - path.join(경로를 나열)
        경로를 합쳐서 하나의 경로를 리턴

      ```jsx
      // 현재 작업 디렉토리와 프로젝트 내의 public 디렉토리 경로 확인
      const path = require("path");

      // 현재 디렉토리를 확인
      console.log(__dirname);

      // 현재 디렉토리 내의 public 디렉토리의 경로
      console.log(path.join(__dirname, "public"));
      ```

   10. url 모듈

       url과 관련된 모듈

       parse 함수: url을 분해

       format 함수: 분해된 url을 하나로 복원

   11. searchParams 모듈

       query string(parameter 라고 하는데 클라이언트가 서버에게 get 방식으로 요청을 할 때 전송하는 데이터)을 위한 모듈

       - 읽어오는 함수
         - getAll(key)
           key에 해당하는 모든 데이터를 가져온다. 체크 박스나 파일의 경우는 다중 선택이 가능
         - get(key)
           key에 해당하는 데이터 1개만 가져온다. 체크 박스나 파일이 아니면 하나의 값만 전달
       - 파라미터를 추가하는 함수
         - append(키, 값) : 추가
         - set(키, 값): 수정

   12. util 모듈

       여러가지 편의 기능을 모아둔 모듈

       util.promisify: 콜백 패턴을 Promise 패턴으로 변경

   13. worker_threads 모듈

       html5에서 Web Worker라는 스레드 관련 API가 추가됨.

       Web Worker를 사용하기 쉽도록 해주는 모듈

       Node는 14버전까지는 싱글 스레드 기반 - 하나의 스레드만 만들어서 사용자의 요청을 순서대로 처리. 14버전 이후에 멀티 스레드를 지원

       express 모듈로 웹 서버를 만들면 멀티 스레드 형식으로 사용자의 요청을 처리해준다.

   14. child_process 모듈

       다른 프로세스(명령어)를 실행하는 모듈

       이 모듈을 사용하게 되면 운영체제 별로 분기를 해서 명령어를 사용해야 한다.

       문자열을 비교할 떄는 일치하는 것을 찾는 경우보다는 포함된 경우를 찾는 경우가 많다.

       indexOf는 포함된 문자열의 시작 위치를, 그렇지 않은 경우는 음수를 리턴하기 떄문에 이 방법을 이용하고, 대소문자를 구분하는 것인지 아닌지를 판단해서 작성해야 한다.

6. **암호화**

   crypto 모듈을 암호화에 이용

   1. 암호화 방식
      - 단방향 암호화
        암호화는 가능하지만 암호화된 문장을 이용해서 복호화(원래 문장을 찾아내는 것)하는 것은 불가능
        원본 데이터와의 비교는 가능(동일한 문장을 암호화하면 동일한 결과가 만들어지기 때문)
        해시 기법(문자열을 고정된 길이의 다른 문자열로 만드는 방식)을 주로 이용
        알고리즘으로는 md5, sha1, sha256, sha512 등이 사용되는데 md5와 sha1은 취약점이 발견되서 거의 사용하지 않는데 안드로이드에서 가끔 sha1 알고리즘을 사용한다.
        블록 체인에서는 sha256을 사용하닥 sha512로 변환 중이다.
        비밀번호 저장이나 블록 체인에서는 단방향 암호화를 주로 이용
        - createHash(알고리즘): 사용할 알고리즘 설정
        - update(문자열): 변환할 문자열을 설정
        - digest(인코딩 방식): 인코딩할 알고리즘을 설정하는데 주로 base64를 많이 이용
      - 양방향 암호화
        암호화 할 때 키를 사용해서 암호화하는 방식으로 복호화가 가능
        암호화할 때 사용한 키와 복호화할 때 사용한 키가 같아야만 복호화가 가능.
        동일한 데이터를 암호화했을 때 암호화된 결과가 다를 수도 있다.
        이 데이터는 비교 연산을 잘 하지 않고 복원해서 사용하는 경우가 대부분이다.
        일반 데이터 암호화에 이용한다
        - createCipheriv(알고리즘, 키, 초기화벡터): 양방향 암호화 객체 생성
        - 암호화 객체.update(암호화할 문자열, 문자열 인코딩 방식 - utf8, 출력 인코딩 방식 - base64): 문자열이 리턴됨.
        - 암호화 객체.final(출력 인코딩 방식)
        - cerateDecipheriv(알고리즘, 키, 초기화벡터): 양방향 복호화 객체 생성 - 암호화할 때 사용한 것을 그대로 대입
        - 복호화 객체.update(복호화할 문자열, 문자열 인코딩 방식 - utf8, 출력 인코딩 방식 - base64): 문자열이 리턴됨.
        - 복호화 객체.final(출력 인코딩 방식): 암호화가 완료

7. **파일 시스템**

   파일 읽고 쓰기

   파일을 읽고 쓰기 위한 모듈은 fs

   1. 파일 읽기
      - fs.readFile(”파일 경로”, [options], 콜백 함수)
        비동기 방식으로 읽음
        콜백 함수는 매개변수가 두 개인데 첫 번째는 에러가 발생했을 때 에러 내용을 가지고 있고 두 번째 매개변수가 읽기에 성공했을 때 읽어낸 데이터
      - fs.readFileSync(”파일 경로”, [options])
        동기식으로 읽어내고 읽어낸 데이터를 리턴
   2. Buffer
      - buffer
        데이터를 저장하기 위한 메모리
      - buffering
        데이터를 한꺼번에 처리하기 위해서 데이터를 모으는 작업
      - readFile이라는 함수는 읽어내고난 후 Buffer 객체를 리턴.
      - Buffer 객체에는 크기를 알려주는 length 속성, 그리고 문자열을 Buffer로 변경하는 from 함수, Buffer의 내용을 문자열로 변환하는 toString 함수 등이 포함되어 있다.
   3. 변경 가능하거나 변하지 않는 중요한 문자열은 파일이나 데이터베이스에 저장하고 읽는 방식을 사용

      운영 환경과 개발 환경이 다른 경우 소스 코드를 수정하게 되면 컴파일을 다시하고 빌드를 다시 시작해야 한다.

      파일에 기록 → 소스 코드에서는 파일의 내용을 읽는 방법.

      클라이언트에 배포하는 프로그램을 만든 경우라는 대부분의 언어는 역 어셈블(실행이 되는 코드에서 소스 코드를 찾아가는 과정)이 가능

   4. 동기식 파일 읽기

      텍스트 파일을 추가하고 샘플 데이터를 작성

   5. 비동기식 파일 읽기

      error는 에러의 내용이고 data가 Buffer

   6. fs모듈의 기타 함수

      - access(경로, 옵션, 콜백)
        디렉토리나 파일에 접근할 수 있는지를 확인. 접근이 안되면 에러 발생.
      - mkdir(경로, 콜백)
        경로를 생성
      - open(경로, 옵션, 콜백)
        경로의 파일을 열고 아이디를 리턴하는데 파일이 없으면 생성
      - rename(기존 경로, 새 경로, 콜백)
        이름 변경
      - unlink(경로, 콜백)
        파일 지우기
      - rmdir(경로, 콜백)
        디렉토리 삭제

      이 함수들의 콜백은 에러 객체를 넘겨받는다.

      에러 객체가 존재하면 에러가 발생한 것이고 그렇지 않으면 발생하지 않은 것이다.

      이미지 파일을 업로드하는 애플리케이션을 생성(SNS)하거나 할 때 id에 따른 디렉토리같은 것들을 만들어줘야 함.

8. **Stream**

   데이터의 흐름

   데이터를 일정한 크기로 잘라서 여러 번에 나누어서 처리

   용량이 큰 파일을 한 번에 읽어내려고 하면 버퍼의 크기가 너무 커져서 메모리 부담이 생기게 됨.

   이렇게 작게 잘라서 처리하는 것을 chunk라고 한다.

   로그 파일을 읽을 때 이런 방식을 사용한다.

   스트리밍: 일정한 크기의 데이터를 지속적으로 전달하는 작업.

   1. 작업
      - 모듈의 createReadStream 메서드나 createWriteStream 메서드를 이용해서 스트림을 생성 - 파일 경로와 highWaterMark 옵션을 이용해서 버퍼의 크기를 설정
      - 읽기 스트림의 경우 data(하나의 버퍼를 읽었을 때 생성), end(읽기 끝났을 때 발생), error(오류 발생) 이벤트를 처리
      - 쓰기 스트림의 경우 drain, finish, error 이벤트를 처리
      - 스트림을 이용한 읽기
   2. 스트림을 사용하는 이유 확인

      용량이 큰 파일을 생성(깃에 올릴때는 제한이 있으니 제외할 것)

      스트림을 사용하지 않고 복사 - 기존 메모리 크기에 파일의 크기 만큼의 메모리가 추가로 필요. 300MB 이상의 차이

      스트림을 사용하고 복사 - 파일의 내용을 잘라서 읽기 때문에 파일의 크기 만큼의 메모리가 추가로 필요하지 않음.

9. **ThreadPool**

   pool: 만들어서 모아 놓은 것

   pool은 서버에서 사용

   Server: 요청을 처리하고 응답을 전송하는 쪽. 속도나 효율을 중요시. 자주 사용되는 것들은 미리 만들어두고 사용을 바로 할 수 있도록 해야 한다.

   Client: 요청을 전송하고 응답을 출력하는 쪽. 신뢰성이나 가용성을 중요시. 메모리 효율을 높여야 하기 때문에 사용하기 직전에 만드는 것을 권장.

   ThreadPool이란 Thread(작업 도중 다른 작업을 할 수 있도록 하는 작업의 단위 - 독자적으로 실행할 수 없음)를 미리 만들어서 모아놓은 것이다.

   독자적으로 실행이 가능한 단위는 Process이며, Thread는 Process 안에 존재하는 실행 단위이다.

   node에서는 몇몇 작업에 한해서는 ThreadPool을 이용해서 처리

   대표적으로 fs(파일 입출력 모듈), crypto(암호화 모듈), zlib, dns, lookup 등이 있다.

   비동기나 스레드 형태로 처리를 하는 작업들은 일반적으로 오랜 시간이 걸리는 작업들이다.

   노드에서는 4개의 스레드를 만들어두고 활용한다.

   노드에서 파일을 비동기적으로 읽거나 암호화를 하게 되면 순서대로 처리가 안되는 경우가 많다.

10. **이벤트 처리**

    1. 이벤트 연결

       ```jsx
       객체.addEventListener("이벤트이름", 함수);
       객체.on("이벤트이름", 함수); // 동일함
       객체.once("이벤트이름", 함수); // 이벤트가 처음 발생할 때만 함수를 수행하고 다음부터는 함수를 수행하지 않음.
       ```

    2. 이벤트 삭제

       ```jsx
       객체.removeEventListener("이벤트이름", 함수); // 함수만 제거
       객체.removeAllEventListener("이벤트이름"); // 모든 함수가 제거
       ```

    3. 이벤트 강제 발생

       ```jsx
       객체.emit("이벤트이름");
       ```

    4. 이벤트에 10개 이상의 함수를 연결하고자 하는 경우

       기본적으로 에러인데 ‘객체.setMaxListeners(개수)’를 호출하면 개수만큼 연결 가능.

11. **예외 처리**

    에외가 발생하게 되면 프로그램이 중단된다. 서버는 아주 위험한 예외가 아니라면 프로그램이 중단되면 안됨.

    서버 프로그래밍에서는 대다수의 코드를 예외 처리 구문 안에 삽입을 해서 예외가 발생하면 예외를 기록하고 계속 작업을 수행하도록 해야함.

    ```jsx
    try{
    	에외 발생 가능성이 있는 코드
    } catch(예외 객체) {
    		예외가 발생했을 때 수행할 내용
    } finally {
    		예외 발생 여부에 상관없이 수행할 동작
    }

    // catch와 finally 중 하나는 생략 가능함.
    ```

    학습을 할 때는 catch 블럭에서 예외를 확인하는 코드를 작성하지만 실무에서는 예외를 던지고(기록하고) 알림을 준다.

    1. 예외 처리의 목적
       - 예외가 발생하더라도 계속 동작하게 하기 위해서
       - 예외를 로깅하기 위해서
    2. 예외 객체의 멤버
       - name: 예외 이름
       - message: 예외에 대한 설명
    3. 강제로 예외 발생
       - throw new Error(”예외 미시지”);
    4. 노드에서 예외가 발생해도 예외 처리를 하지 않아도 되는 경우

       `콜백 함수의 매개변수가 예외 객체인 경우는 예외 처리를 하지 않아도 된다.`

       이미 예외 처리 구문으로 감싸져 있고 예외 객체를 넘겨주므로 예외 객체의 존재 여부를 가지고 예외 발생 여부를 판단해서 작업만 작성해주면 된다.

    5. 자주 발생하는 에러
       - command not found
         터미널에서 명령어를 잘못 입력했거나 명령어가 없거나 명령어가 있는 곳을 path라는 환경 변수에 설정을 하지 않은 경우
       - 모듈 is not defined
         모듈을 가져오지 않았거나 모듈 이름을 잘못 기재한 경우
       - EADDRINUSE 포트번호
         이미 포트를 사용 중인 경우. 포트를 사용 중인 프로세스를 종료하고 수행
         - 포트를 사용중인 프로세스 찾기
           windows: ‘netstats -ano | findstr 포트번호’
           그 외: ‘lsof -l tcp:포트번호’
         - 프로세스 종료
           windows: ‘taskkill /pid 프로세스아이디 /f’
           그 외: ‘kill -9 프로세스아이디’

12. **NPM(Node Package Manager)**

    노드에서의 패키지 매니저인데 지금은 거의 모든 자바스크립트 라이브러리들이 저장소에 있기 때문에 자바스크립트 라이버르리들은 거의 모두 NPM을 이용해서 사용

    1. package.json

       노드에서 패키지 관리를 위한 설정 파일

       java에서의 build.gradle이나 pom.xml의 역할을 수행.

       패키지를 설치하게 되면 패키지에 대한 정보가 전부 작성된다.

       패키지를 설치하게 되면 `package-lock.json` 이 생성되는데 package.json에는 직접 설치한 패키지에 대한 정보만 기재되어 있지만 package-lock.json에는 의존 관계(이 패키지를 사용하기 위해서 필요한 패키지)가 있는 모든 패키지에 대한 정보가 기재되어 있다.

    2. 패키지 설치 개념

       ```bash
       npm install 패키지이름나열(나열할 때는 공백으로 구분)
       ```

       개발 과정에서만 사용하고 배포할 때는 제외하고자 하는 경우에는 패키지 이름 앞에 `--save-dev` 를 추가하면 된다.

       모든 프로젝트에서 사용할 수 있도록 하기 위해서는 `global` 모드로 설치하는데 패키지 이름 앞에 `-g` 를 추가하면 되는데 지금은 경고가 발생하면서 `--location=global` 로 설정하기를 권장한다.

       Mac이나 Linux에서 global로 설치할 때는 맨 앞에 관리자 모드를 의미하는 `sudo`를 추가해야 한다. 처음 한 번은 관리자 비밀번호를 입력해야 한다.

       ```bash
       sudo npm install --location=global
       ```

       설치된 패키지는 프로젝트 내의 `node_modules` 라는 디렉토리에 저장된다.

       전역으로 설치했는데 패키지가 잘 불러지지 않으면 로컬로 설치해서 사용하면 된다.

       전역으로 설치했는데 패키지가 잘 불러지지 않는 경우는 보통 2가지의 경우가 있다.

       - node 명령에 대한 path 설정이 되어있지 않다.
       - node를 2개 이상 설치한 경우이다.

    3. 패키지 설치

       - 프로젝트 생성 - npm init - package.json이 만들어졌는지 확인
       - express 패키지 설치: express는 웹 애플리케이션을 만들어주는 패키지
         ```bash
         npm install express
         ```
       - morgan, cookie-parser, express-session 패키지 설치
         ```bash
         npm install morgan cookie-parser express-session
         ```
       - nodemon 패지키 설치
         nodemon 패키지는 소스 코드를 수정하면 자동으로 재실행되게 해주는 패키지로 `개발 과정에서만 사용`.
         ```bash
         npm install --save-dev nodemon
         ```
       - rimraf 패키지 설치
         rimraf 패키지는 윈도우 터미널에서 rm 명령을 사용하기 위해 설치(mac은 안해도 됨.)
         전역으로 설치해보기

         ```bash
         // window
         npm install --location=global rimraf
         // --location=global 대신에 -g라고 입력해도 된다.

         // Mac이나 Linux에서는 앞에 sudo를 추가해야 한다.
         ```

    4. 패키지 재설치

       모든 패키지는 node_modules에 다운로드 받아서 저장하게 되는데 배포를 하거나 코드를 가지고 갈 때 node_module를 포함시키면 크기가 너무 커지는데 이런 경우에는 `node_modules는 복사하지 않고 package.json만 가져간 후 새로운 곳에서 npm init 명령만 다시 수행하면 패키지들이 전부 설치가 된다.`

       (깃헙에서 node_modules는 제외시키자. 중요한 것은 package.json이다)

    5. 패키지 버전

       3자리로 구성

       Major Version, Minor Version, Patch

       - Major Version이 변경되는 경우에는 하위 버전과 호환이 안될 수 있음
       - Minor Version은 기능이 변경된 경우
       - Patch는 오류를 수정했을 때 변경

       버전 이름에 alpha나 beta가 포함되면 테스트 버전이다.

    6. npm 관련 명령어

       - npm uninstall 패지키이름: 패키지 삭제
       - npm search 검색어: 패키지 검색
       - npm publish: 패키지 배포
       - npm unpublish: 배포 취소 - 배포 한 후 24시간 이내에 해야함.

       이런 명령어들은 [https://docs.npmjs.com에서](https://docs.npmjs.com에서) 확인 가능.
