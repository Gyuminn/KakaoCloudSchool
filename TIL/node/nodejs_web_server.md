# [Node.js] 웹 서버 만들기

실제로는 대부분 이 방법을 사용하지 않고 express 모듈을 이용하는 경우가 많음

1. **최근의 Web**
   1. web 3.0
      - Semantic Web 개념 등장
        로봇이 정보 자원의 뜻을 이해하고 논리적 추론까지 가능, 명확한 의미 전달이 중요하고 Rest API가 뜨게 되었다.
      - 속도의 변화
      - 인공지능
      - 자신만의 컨텐츠나 정보를 구성할 수 있도록 하는 사용자의 권한이 증가
      - 블록체인
   2. WOA(Web Oriented Architecture)
      - 사용자의 요구 사항 변경
        여러 디바이스를 사용하고 디바이스끼리 끊어짐이 없는 서비스 요구가 증대되면서 이를 구현하기 위한 방법으로 웹 기술이 각광받음.
      - 기술의 변화
        인프라 측면에서는 클라우드나 가상화 기술이 각광을 받고 있고 소프트웨어 측면에서는 WOA(전체 시스템 아키텍쳐를 웹을 중심으로 설계)
      - Framework를 이용한 애플리케이션 개발
2. **웹 서비스 구축 방식**

   1. 정적 웹 서비스

      요청이 오면 요청에 해당하는 HTML 페이지를 찾아서 출력하는 방식

   2. CGI(Common Gateway Interface)

      클라이언트의 요청이 오면 서버가 작업을 수행해서 결과를 전송하거나 화면을 전송하는 방식

      Perl이 시초

      이 방식은 사용자의 요청을 별도의 프로세스로 만들어서 처리

      하나의 요청을 전부 처리하기 전까지는 다른 요청을 처리할 수 ㅇ ㅓㅂㅅ음.

      Perl이나 ASP가 이런 형태로 동작

   3. Application Server 방식

      사용자의 요청을 Thread를 만들어서 처리

      여러 사용자의 요청을 한꺼번에 처리하는 것처럼 처리

      Java → Servlet(JSP) → Spring Framework

      C# → asp.net

      JavaScript → node.js Framework

      PHP → laravel Framework

      Python → Flask나 Django Framework

      Ruby → Rails

   4. 웹 프로그래밍의 구조

      웹 브라우저 ↔ 웹 서버 ↔ 애플리케이션 서버(Controller, Service, Repository) ↔ 데이터 젖아소

      언어나 프레임워크는 애플리케이션 서버를 만들기 위한 기술

      Serverless는 서버가 없는 것이 아니고 서버를 직접 구현할 필요가 없는 것.

      웹 브라우에서 서버에게 요청하는 것을 `request`라고 하고 서버가 웹 브라우저에게 대답을 하는 것을 `response`라고 한다.

3. **http 모듈**

   내장 모듈이므로 별도로 설치할 필요없음

   1. 서버 생성

      ```jsx
      http모듈.createServer((request, response) => {
        내용;
      });
      ```

   2. 서버 실행

      ```jsx
      서버객체.listen(포트번호, 아이피주소);
      // 아이피 주소는 현재 컴퓨터에 여러 개의 IP가 존재하는 경우 작성
      ```

   3. 서버 종료

      ```jsx
      서버객체.close();
      ```

   4. 서버에 발생하는 이벤트
      - request: 클라이언트의 요청이 있을 때
      - connection: 클라이언트가 접속했을 때
      - clientError: 클라이언트 오류가 발생했을 때
   5. request 객체
      - url: 요청 주소
      - method: 요청 방식(GET, PUST, PUT, PATCH, DELETE, OPTION 등)
   6. 웹 서버 만들고 직접 응답을 생성하기

      js 파일을 추가한 후 작성하고 실행

      클라이언트에서 접속

      - 브라우저를 실행하고 url을 입력
      - 자기 컵퓨터의 경우는 `http://localhost:포트번호` 또는 `http://127.0.0.1:포트번호`
      - 다른 컴퓨터의 경우는 `http://서버컴퓨터의 IP:포트번호` (서버 컴퓨터의 방화벽이 해제되어 있어야 한다.)

      서버 중지는 터미널에서 Ctrl + C 인데 안되면 메시지를 확인

   7. 서버에서 html 파일을 읽어서 출력

      프로젝트에 출력할 html 파일을 만들고 작성

   8. request 객체
      - url: 클라이언트의 요청 경로
        요청 경로를 만들 때는 이해하기 쉬운 경로를 만들어주어야 하고 \_ 사용은 하지 않는 것을 권장
      - method: 요청 방식
        - GET: 서버 자원을 가져올 때 사용(조회 - READ)
        - POST: 서버에 자원을 등록하고자 할 때 사용(삽입 - CREATE)
        - PUT: 서버의 자원을 수정하고자 할 때 사용(수정 - UPDATE)
        - PATCH: 서버의 자원을 일부분만 수정하고자 할 때 사용(수정 - UPDATE, 권장 X)
        - DELETE: 서버 자원을 삭제하고자 할 때 사용(삭제 - DELETE)
        - OPTIONS: 요청을 하기 전에 통신 옵션을 설명하기 위해서
   9. REST(Representational State Transfer) API
      - 서버의 자원을 정의하고 자원에 대한 URL을 지정하는 방법
      - URL과 Method만으로 작업을 예측할 수 있도록 하는 것.
        URL은 /member 이고 Method는 POST라면 회원 가입
      - 클라이언트의 종류에 상관없이 동일한 작업은 동일한 URL로 처리
      - 클라이언트 애플리케이션을 서버 애플리케이션과 분리해서 구현하고 서버는 클라이언트의 뷰를 만들지 않고 데이터를 전송한다.
      - 클라이언트 애플리케이션과 서버 애플리케이션을 하나의 프로젝트로 구현하면 모바일 기기의 Native Application과 Web Browser의 요청에 응답하는 부분을 동일한 URL로 처리할 수 없음.
        아이폰에서 회원 가입이 URL은 /member 이고 Method는 POST라면 안드로이드에서 동일해야 하고 Web Browser에서도 동일한 URL로 처리되어야 한다.
        이렇게 만들어진 서버를 RESTful 하다라고 한다.
   10. axios 라이브러리

       브라우저나 Node.js에서 Promise API를 이용해서 HTTP 비동기 통신을 할 수 있도록 해주는API

       자바스크립트의 fetch api를 사용하기 쉽도록 해주는 라이브러리

       | axios 라이브러리                         | fetch api                                      |
       | ---------------------------------------- | ---------------------------------------------- |
       | 별도로 설치                              | 설치할 필요가 없음                             |
       | XSRF 보호 제공                           | 별도로 제공하지 않음                           |
       | 응답을 받으면 결과는 JSON 파싱한 결과    | .json()을 호출해야 파싱된 결과를 만들 수 있음. |
       | 요청을 취소할 수 있고 타임아웃 설정 가능 | 기능없음                                       |
       | 다운로드 진행 중을 확인할 수 있음        | 기능없음                                       |

       XSRF(Cross-Site Request Forgery): 쿠키만으로 인증하는 서비스의 취약점을 이용해서 사용자가 모르게 서비스에 특정 명령을 요청하는 것.

       Promise를 이용한 사용

       ```jsx
       const axios = require("axios");
       axios
         .요청메서드(url)
         .then((response) => {
           // 성공했을 때 수행할 내용
           // response는 가져온 데이터를 파싱한 결과
         })
         .catch((eroor) => {
           // 에러가 발생했을 때 수행할 내용
           // error는 에러에 대한 내용을 저장한 객체
         })
         .then(() => {
           // 성공과 실패 여부에 상관없이 수행할 내용
         });
       ```

   11. Cookie와 Session

       HTTP나 HTTPS는 상태가 없음

       클라이언트가 서버에게 요청을 할 때 일시적으로 연결이 된 후 서버가 응답을 하고 나면 연결이 해제되어 버리기 때문에 연결이 될 때는 이전에 어떤 상태였는지 알 수 없음.

       클라이언트와 서버가 이전에 어떤 상태였는지 알 수 있도록 하기 위해서 Cookie와 Session의 개념을 사용

       - Cookie
         클라이언트에 저장해서 클라이언트가 서버에게 요청할 때 마다 전송되는 객체
         `쿠키는 http나 https 요청의 헤더에 저장하고 이름과 값의 구조`
         node의 http 모듈에서 다음과 같은 형태로 작성
         ```jsx
         response.wrtieHead(코드, { "Set-Cookie": "쿠키이름-값" });
         ```
         쿠키가 여러 개이면 세미콜론을 하고 추가
         쿠키의 옵션으로는 `이름, Expires(만료 시간 - 날짜), Max-age(만료 시간 - 초), Domain(도메인), Path(URL), Secure(HTTPS인 경우만 전송), HttpOnly(자바스크립트에서 수정을 못하도록 하는 경우)`
       - Session
         클라이언트의 정보를 서버에 저장하는 기술
         클라이언트에 저장하게 되면 노출이 되고 이를 수정할 수 있기 때문에 보안에 취약.
         노출이 되면 안되는 데이터를 서버에 저장하고 클라이언트에서는 이 정보를 구별할 수 있는 세션 키만 저장
         클라이언트와 서버가 동일한 도메인인 경우만 가능한데 쿠키를 이용하면 클라이언트와 서버의 도메인이 달라도 가능.
         주로 로그인 정보를 저장할 때 많이 이용을 했는데 최근에는 `JWT(Json Web Token)`을 이용하는 것을 권장하면서 사용 빈도는 줄어들었다.
       - Cookie 대안
         Web Storage, Web SQL, Indexed DB 같은 HTML5 API를 이용하기도 한다.

   12. https 모듈

       http 서버를 https 로 변경하기 위한 모듈

       https는 암호화를 위한 인증서가 필요 - 무료나 유료로 인증서를 발급받아야 이 모듈을 사용하는 것이 가능

       https는 데이터가 암호화되어서 전송되기 때문에 중간에 가로채도 변경을 할 수 없다.

       https를 사용하면 데이터 전송 간에는 암호화를 할 필요가 없는데 개발자들은 혹시 모르니 해야 한다고 한다.

       최근에는 브라우저에서 https 서버가 아니면 접속을 못하도록 하기도 한다.

       스마트 폰에서는 http에 접속하려면 별도의 설정을 추가해야 한다.

       https 모듈의 속도를 개선한 https2 모듈도 있다.

   13. cluster

       CPU 코어를 전부 사용할 수 있도록 해주는 모듈

       여러 개의 연산을 동시에 수행할 수 있도록 해주는 모듈

       직접 서버 설정을 한다면 사용을 하지만 최근처럼 Cloud를 사용하는 경우는 직접 설정하지 않음.
