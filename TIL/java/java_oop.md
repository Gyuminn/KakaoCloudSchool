# [Java] OOP

1. **객체 지향**

   관련있는 속성과 기능을 하나로 묶어서 사용하는 것.

   Java는 완전한 객체 지향 언어 - Java는 class 이외의 공간에 실행되는 코드를 작성할 수 없음.

   1. 특징
      - Encapsulation(캡슐화)
        속성과 기능을 묶는 것.
        Information hiding(정보 은닉 - 불필요한 정보는 숨기고 필요한 부분만 외부로 노출)을 통해 클래스와 인스턴스를 만드는 것.
      - Inheritance(상속)
        상위 클래스의 모든 것을 하위 클래스가 물려받는 것.
      - Polymorphism(다형성)
        동일한 메시지에 대하여 다르게 반응하는 성질 - 동일한 코드가 다른 메서드를 호출하는 것.
   2. 객체 지향의 장점
      - 재사용성이 증가
        중복되는 코드를 클래스 단위로 작성을 해서 상속을 이용하면 재사용성이 증가
      - 코드 관리 용이
        관련있는 속성과 메서드를 묶어놓았기 때문에 관리하기 편리
      - 신뢰성이 높은 프로그래밍이 가능
        접근 제한

2. **Class와 Instance**

   1. Class
      - 동일한 목적을 가진 속성(변수 - 데이터)과 기능(메서드 - method)의 집합
      - 사용자 정의 자료형 - 개발자가 원하는 대로 만들어서 사용
      - 유사한 인스턴스들의 설계도
      - 자바에서 클래스는 프로그램을 실행할 때 정적 영역에 메모리를 할당해서 저장되고 정적인 형태로 존재한다.
   2. Object(객체)

      프로그램에 존재하는 모든 것.

      Class를 기반으로 만들어진 Object를 Instance

   3. Instance

      Class를 기반으로 만들어진 Object

      new 라는 연산자로 constructor를 호출해서 생성

      동적 - 필요한 내용을 수정할 수 있고 삭제할 수 있다.(추가는 안됨.)

3. **Class 구성 요소**

   1. 속성(property): field, state, attribute
      - static 속성 - class가 소유(공유)
      - instance 속성 - instance가 소유
   2. 기능(method): behavior(행위)
      - static method - 클래스가 호출
      - instance method - 인스턴스가 호출
   3. Constructor(생성자)

      인스턴스를 만들 때 호출하는 특별한 용도의 메서드

   4. 초기화 블럭
      - static 초기화
      - instance 초기화
   5. Nested Class

      클래스 안에 만들어진 클래스

4. **클래스 생성**

   ```java
   [public이나 생략 - package] [클래스 특성] class 클래스 이름 [extends 클래스 이름] [implements 인터페이스 이름 나열] { 내용 }
   ```

   대부분의 IDE에서는 이름만 정하면 나머지는 선택할 수 있도록 해준다.

   public 부분은 접근 제한자라고 하는데 클래스 안에 만들어지는 클래스는 private나 protected도 가능.

   클래스 특성으로는 `abstract(추상 - 상속을 통해서만 사용)`나 `final(종단 - 상속을 할 수 없는 클래스)`이 가능

   `extends` 는 상속을 받고자 하는 경우에 사용하는 것으로 생갹하면 `java.lang.Object` 클래스로부터 상속받음.

   `implements` 는 인터페이스를 구현하고자 할 때 사용

   클래스 이름은 대문자로 시작하는 것이 관례.

   소스 파일 이름

   - 하나의 파일 안에 존재하는 클래스 이름으로 만들어져야 함.
   - 하나의 파일에 여러 개의 클래스를 만드는 것이 가능한데 public 클래스는 1개만 생성 가능
   - public 클래스가 없는 경우에는 아무 클래스 이름이나 상관없음.
   - 하나의 파일에 여러 개의 클래스를 만들고 컴파일을 하게 되면 클래스 파일은 여러개가 된다.
   - 이렇게 만들어진 클래스 파일을 자바에서는 byte code라고 한다.
   - 이 byte code를 JRE(JVM이 JRE보다는 작은 개념)가 보고 운영체제가 이해할 수 있는 코드로 번역해서 실행한다.

5. **인스턴스 생성**

   1. new 라는 연산자를 이용해서 생성자를 호출하면 Heap 영역에 메모리 할당을 하고 그 참조를 리턴.

      생성자 이외의 메서드를 이용해서 만들어진 것은 디자인 패턴이 적용돼서 내부적으로 생성자를 호출해서 리턴하거나 메서드 내부에서 직접 생성해서 리턴하는 경우이지 생성자를 호출하지 않고 인스턴스를 생성할 수는 없다.

      ```java
      new 생성자(매개변수); // 인스턴스 생성 구문

      클래스이름 참조형현수 = new 생성자(매개변수);
      // 인스턴스를 생성하고 재사용하기 위해서 인스턴스의 참조를 변수에 기억시키기
      ```

   2. 인스턴스 소멸

      인스턴스를 참조하는 변수가 없으면 인스턴스는 메모리 정리 대상이 된다.

      ```java
      참조형변수 = null;
      // 정리 대상이 될 수는 있는데 다른 참조형 변수가 가리키고 있으면
      // 정리 대상이 안되고 정리 대상이 되더라도 바로 소멸되지 않고
      // Garbage Colletion이 나중에 메모리 정리를 함.
      ```

6. **속성이나 메서드 호출**

   클래스 이름이나 인스턴스이름.속성이름 또는 메서드이름(매개변수 나열)

   클래스 내부의 메서드 안에서 자신의 속성이나 메서드를 호출할 떄는 클래스 이름이나 메서드 이름을 생략할 수 있다.

   entry point에 해당하는 메서드는 java 클래스이름 만으로 호출

7. **클래스와 인스턴스 만들기**

   클래스를 만들어서 사용할 때는 사용할 클래스들을 별도의 파일에 만들고 main 메서드를 소유한 클래스에서 이 클래스들을 호출해서 사용

   1. 학생에 대한 정보를 저장할 클래스 생성 - Student
   2. 클래스를 가져와서 사용할 main 메서드를 소유한 클래스를 생성 - Main

8. **property(속성)**

   1. 속성

      class나 instance에 데이터를 저장하기 위해서 생성하는 변수

   2. 변수의 종류
      - Local Variable(지역 변수)
        함수나 메서드 안에 만들어져서 자신의 영역 내에서만 사용할 수 있는 변수
      - Member Variable(Instance Variable)
        클래스 안 메서드 외부에 static이 없이 선언되는 변수
        Instance가 각자 소유하는 변수 - 속성이라고 부름.
      - Static Variable
        클래스 안 메서드 외부에 static 이라는 키워드와 함께 선언되는 변수
        Class가 소유하는 변수
   3. 속성 선언

      ```java
      [접근 제한자] + [transient] + [volatile] + [static] + [final] + 자료형 + 이름 [= 초기값];
      ```

   4. 접근 제한자

      - public
        클래스 내부에서 사용가능하고 외부에서(클래스 이름이나 인스턴스 이름으로도 접근 가능) 도 사용가능하도록 생성
      - package
        생략하는 것인데 자신의 package에서는 public으로 동작하고 다른 package에서는 private으로 동작
      - protected
        자신의 클래스 내부와 상속받은 클래스 내부의 메서드에서 사용 가능 + `자신의 패키지 내에서는 public`
      - private
        클래스 내부의 메서드에서만 사용이 가능

      public > protected > package > private

      - transient
        직렬화 대상에서 제외할 때 사용
      - volatile
        이 속성을 사용할 때 복제하지 않고 직접 사용하도록 할 때 사용
      - static
        static 속성을 만들 때 사용
      - final
        읽기 전용을 만들 때 사용

      transient, volatile, static, final은 순서에 상관없이 적용 가능

      초기값을 설정하는 것은 생성자나 static 초기화를 이용하는 것을 권장하고 직접 초기값을 설정하는 것은 비추천.

      속성은 만들어질 때 자동 초기화(숫자 - 0이나 0.0, boolean - false, 나머지 자료형 - null)를 수행한다.

   5. static 속성
      - 속성을 만들 때 앞에 static을 추가하면 만들어지는 속성
      - 클래스가 소유하는 속성
      - 외부에서 접근할 수 있도록 만들면 클래스 이름으로 접근이 가능.
        자바에서는 경고가 발생하기는 하지만 인스턴스를 이용해서도 접근이 가능.
      - 생성하는 목적
        모든 인스턴스가 공유하는 변수를 만들고자 하는 경우
        전역 변수를 만들고자 할 때 사용 - 자바는 클래스 외부에 변수를 선언할 수 없기 때문에 기본적으로 전역 변수를 만들 수 없음.
        객체 지향 프로그래밍에서는 전역 변수 사용을 금기시 함. 객체 지향은 필요한 부분만 외부에 노출하라고 하기 때문에
        `자바에서는 전역 변수를 singleton 패턴으로 디자인해서 사용`
      - static 초기화
        `클래스 안에 static { }를 하고 실행되는 코드를 작성하면 클래스가 메모리에 로드가 될 때 코드를 수행한다.`
        static 속성(변수) 사용과 지역 변수를 생성해서 사용하는 것도 가능하다.
        인스턴스 속성을 사용하는 것은 안됨.
        static 속성에 초기값을 부여하고자 할 때 주로 이용한다.
        프로그램 내에서 맨 처음 한 번만 수행할 내용이 있는 경우도 이 블럭을 이용하면 된다.
   6. final 속성
      - 변수 앞에 final을 붙이면 읽기 전용이 된다.
      - 지역 변수를 만들 때 final을 붙일 거라면 반드시 생성하자마자 초기화를 해야 한다.
      - 클래스 안에 만들 때는 대부분의 경우 static과 함께 사용한다. 값을 바꿀 수 없으니 굳이 여러 개를 만들 필요가 없기 때문
      - 클래스 안에 만들 때는 생성하자마자 초기화를 해도 되고 생성자에서 초기화해도 된다. 다른 곳에서는 초기화가 되지 않는다.
      - 클래스 안에 만들어지는 final은 대부분은 클래스 안의 메서드에서 사용하는 옵션인 경우가 많다.
      - Java API에서 입력 값에 대한 제한을 하고자 할 때 주로 이용한다.
      - 개발자는 대부분 ENUM을 이용하는데 Java API에서는 호환성 문제 때문에 정수 상수를 주로 이용한다.
      - 다른 데이터와의 구별 문제 때문에 이름은 대문자만 사용하는 것이 관례이다. 이러한 명명법을 `Snake 표기법`이라고 한다.
   7. 객체 지향에서의 속성에 대한 접근 지정자
      - 객체 지향에서는 속성을 직접 접근해서 핸들링하는 것을 비추천하기 때문에 속성의 접근지정자는 대부분의 경우 private나 protected인 경우가 많다
      - static final인 경우는 옵션으로 사용해야 하기 때문에 public인 경우가 많다.
      - Java API에서 제공하는 Document에는 일반 속성은 보이지 않고 static final 속성만 외부로 노출된다. Java API에서는 property라는 용어 대신에 filed라는 용어를 사용한다.

9. **Method**

   1. method

      전달받은 인수를 처리해서 결과를 돌려주는 작은 프로그램

      function이라고 하기도 하는데 function은 전역 공간에 만들어져서 어디서나 호출할 수 있는 것이고 method는 클래스 안에 만들어져서 클래스나 인스턴스를 통해서만 사용할 수 있는 것으로 분류한다

   2. method 선언

      ```java
      [접근 지정자] + [특성] + 리턴타입(결과형) + 이름(매개변수 나열){
      	메서드 내용
      }
      ```

      접근 지정자는 속성과 동일

      특성

      - abstract(추상)
        내용이 없는 메서드
      - final(종단)
        overriding 할 수 없는 메서드
      - synchronized
        스레드의 임계 영역 처리를 위한 메서드
      - native
        native 기능(대부분의 경우는 운영체제의 기능을 호출)을 위한 메서드
        Embedde나 System Programming에 이용
      - return type(결과형) - 생략 안됨
        return 하는 데이터의 자료형을 기재하는데 return하는 데이터가 없다면 void라고 설정
      - 매개변수는 없으면 생략 가능

   3. method 호출

      내부에서는 이름과 매개변수 만으로 호출이 가능

      외부에서는 클래스 이름이나 인스턴스 이름을 기재하고 .메서드이름(매개변수)로 호출해야 한다.

   4. method 원형

      `리턴타입 메서드이름(매개변수 자료형 나열)`

   5. UML에서의 메서드 표현

      `이름(매개변수 자료형 나열): 리턴 타입`

   6. method 사용 이유
      - 반복적으로 사용하는 코드를 하나의 이름으로 묶어서 이름을 호출하는 것만으로 코드를 실행하기 위해서 - 재사용성이 증가
      - 일반적인 프로그래밍 언어에서의 함수는 한정된 메모리를 사용하기 때문에 구조화가 필요. 함수의 크기를 줄요서 작성하는 것을 권장 - 20Line 이내
   7. static 메서드와 instance 메서드 차이
      - static 메서드는 외부에서 클래스가 호출해야 한다.
      - instance 메서드는 외부에서 인스턴스가 호출해야 한다.
      - 메서드는 메서드 영역 또는 static 영역이라고 부르는 영역에 하나만 만들어지고 이를 호출해서 사용하는 개념이므로 코드는 기본적으로 공유가 된다.
      - static 메서드를 사용하는 이유는 static 메서드에서는 instance 속성을 사용할 수 없는데(static 속성과 지역변수만 사용 가능) `static 메서드는 인스턴스 생성 없이 메서드를 호출할 수 있다`. 즉, 메모리 절약이 가능하다.
        `클래스 안에 기능 구현이 끝나고 난 후 instance 속성을 사용하지 않는 메서드는 staic 메서드로 수정하는 것이 좋다.`
   8. return
      - 메서드의 수행을 종료하고 호출한 곳으로 돌아가는 명령어
        return 뒤에 있는 문장은 수행되지 않음.
      - 메서드를 호출하면 메서드를 호출하기 위한 참조를 기억하기 때문에 메서드의 호출 결과로 하나의 데이터를 받을 수 있다.
        이렇게 데이터를 받고자 할 때 return 다음에 돌려줄 데이터를 기재하면 된다.
      - 자바에서 이렇게 데이터를 돌려줄 때는 메서드 이름 앞에 돌려줄 데이터의 자료형을 기재해야 하고, 없으면 void라고 적어야 한다.
   9. parameter, argument
      - 메서드를 호출할 때 호출하는 곳에서 넘겨주는 데이터
      - 없을 수 있고 개수 제한은 없다.
      - `여러 개가 되면 순서를 기억해야하기 때문에 매개변수가 여러 개인 경우 그 여러 개를 포함하는 클래스를 만들어서 사용하는 것을 권장한다. 클래스 대신에 Map을 사용하는 경우가 있는데 비추천한다.` Map을 사용하게 되면 가독성이 떨어진다.
      - 자바에서는 메서드를 호출할 때 메서드에 만들어진 매개변수를 생략할 수 없고 더 많이 줄 수도 없다. 즉, 자료형과 개수가 맞아야 한다.
      - 매개변수는 메서드 내의 지역 변수가 된다.
        메서드 외부에서는 사용할 수 없다.
   10. 매개변수와 리턴 사용

       클래스의 메서드를 사용할 때는 static 존재 여부를 확인하고 매개변수의 개수와 자료형을 확인하고 리턴 타입을 확인해야 한다.

       호출을 할 때는 리턴 타입은 의미가 없지만 그 결과를 사용하기 위해서는 return type을 확인해야한다.

   11. Method Overloading
       - 하나의 클래스 또는 상속 관계에 있는 클래스에 이름은 같고 매개변수의 개수나 자료형이 다른 메서드가 존재하는 경우
       - 메서드를 호출할 때 매개변수의 자료형과 개수를 보고 호출할 메서드를 결정
       - Overloading을 판단하는 근거는 메서드이름과 매개변수의 자료형의 순서
   12. 매개변수 전달
       - 기본형은 복제가 되어서 전달
       - 기본형이 아닌 자료형은 참조가 그대로 전달
       - 기본형이 아닌 데이터를 넘겨받아서 내부 요소를 수정하게 되면 넘겨준 데이터가 수정된다.
       - 특별한 경우가 아니면 메서드는 return을 하는데 return을 하지 않는 메서드가 참조형을 매개변수로 받으면 대부분 매개변수를 수정한다.
   13. this

       인스턴스 메서드의 숨겨진 첫 번째 매개변수

       static 메서드에는 this가 없음.

       ```java
       calss T {
       	private int num;
       	public void method() {
       		System.out.println(num);
       	}
       }

       T obj = new T();
       obj.num = 10;
       obj.method(); // 10이 출력 ---> T.method(obj)로 수정되어서
       // 수행되기 때문에 클래스 안에있는 method는
       ```

       속성은 인스턴스가 공유하지만 메서드는 공유한다

       - T 클래스에 대한 정의 ————> obj(num, T에 대한 참조 소유)
       - obj.num: 10
       - obj.method() ———> 메서드를 호출하면 클래스에 가서 메서드를 찾음.

       클래스를 생성하면 Java는 코드를 수정

       ```java
       class T {
       	public int num;
       	public void method(T this = obj) {
       		int x = 20;
       		// num은 메서드 안에서 만든 지역변수가 아니므로 this 추가.
       		System.out.println(this.num);
       		System.out.println(x);
       	}
       }
       ```

       this를 사용하는 경우

       인스턴스 속성과 메서드 내부에서 만든 지역 변수 이름이 같은 경우 변수 이름만 사용하면 scope법칙 때문에 지역변수가 호출 된다.

       이 때 지역 변수를 참조하지 않고 인스턴스 속성을 참조하고자 할 때 this.속성이름

       `this.` 이 붙으면 메서드 내의 지역 변수는 찾지 않는다.

   14. 접근자 메서드

       객체 지향 언어에서는 속성에 바로 접근하는 것을 권장하지 않는다.

       속성에 접근해서 읽어오고 수정하는 메서드를 이용해서 사용하도록 권장한다.

       이러한 메서드를 접근자 메서드라고 한다.

       - getter
         속성의 값을 리턴하는 메서드
         메서드의 이름은 ‘get속성이름’ 으로 하는데 속성 이름의 첫 글자만 대문자로 변경한다.
         메서드의 내용은 속성의 값을 리턴하는 것만 한다.
         메서드의 이름을 변경하는 경우가 있는데 이 경우는 속성의 자료형이 boolean인 경우 get 대신에 is를 사용
         get 할 때 생성을 해서 리턴을 하는 경우도 있는데 이 경우를 지연 생성이라고 한다.
         대부분의 경우는 생성자에서 미리 생성해두고 사용을 하지만 메모리 부담이 커지거나 생성 속도가 너무 느리다면 처음 get이나 set을 할 때 생성하기도 함.
       - setter
         속성의 값을 설정하는 메서드
         메서드 이름은 getter와 동일한 방식
         매개변수로 1개의 데이터를 받아서 이 매개변수의 값을 속성에 대입하는 역할을 수행한다.
         리턴 타입은 void로 하는 것이 일반적
         속성에 값을 대입하기 전에 유효성 검사를 수행해서 정상적인 값만 사용할 수 있도록 코드를 추가하는 경우가 있다.
         점수는 0~100 사이인데 이 데이터를 저장하고자 하면 int를 사용할 것이고 int의 범위는 절대값으로 21억까지 저장가능하므로 무조건 값을 대입하게 되면 0~100 사이가 아닌 값이 저장될 수 있다.

       getter와 setter는 직접 만들지 않고 대부분의 경우 IDE가 제공하는 기능을 이용하거나 자바의 경우 Lombok 이라는 라이브러리를 이용해서 어노테이션으로 생성.

       여러 개의 값 만을 하나로 묶기 위해서 사용하는 클래스를 `VO(Value Object)`라고 한다. 이 클래스가 영역을 벗어나서 사용되면 `DTO(Data Transfer Object)`라고 하고 데이터베이스 연동이 되면 `Entity`라고 한다.

       setter는 없고 getter만 존재하는 경우도 있는데 이 경우는 읽기 전용을 만들거나 derived 속성(파생 속성 - 다른 속성으로부터 유도된 속성)

   15. recursion(재귀호출)

       메서드가 자기 자신을 다시 호출해서 리턴하는 것.

       사용하는 이유: 코드를 이해하기 쉽게 작성하기 위해서

       단점: 메서드가 다시 자기 자신을 호출해야하기 때문에 메모리 사용량이 늘어나고 수행 속도가 오래 걸릴 수 있음.

       재귀호출을 이용할 수 있는 대표적인 알고리즘이 합계, 팩토리얼, 피보나치 수열, 하노이의 탑 등이 있다.

       재귀를 이용해서 메서드를 만들 때는 종료 지점을 만들어 주어야 한다는 것이다. 그렇지 않으면 무한 루프에 빠질 수 있음.

       ```java
       public 리턴타임 이름(매개변수) {
       	if(종료조건) {
       		return;
       	}
       	return 재귀호출 구문;
       }
       ```

   16. varargs(Variable Arguments)

       매개변수의 개수를 가변으로 설정하는 것

       매개변수를 설정할 때 … 이름을 사용하게 되면 메서드를 호출할 때 몇 개의 데이터를 대입하더라도 이름의 배열로 묶어서 처리

       매개변수 중에서 맨 마지막에 1번만 사용 가능.

       중간에 포함되거나 여러 번 사용하게 되면 어디까지를 배열에 대입해야할 지 알 수 없기 때문이다.

       이름은 [ ]가 없어도 배열로 처리된다.

       System.out.printf 메서드가 대표적으로 varags를 사용한다.

   17. 메서드 사용

       클래스의 메서드를 사용하고자 할 때는 static의 여부를 확인하고 매개변수를 확인한 후 reurn type을 확인해야 하며 나중에 예외 처리의 강제 여부까지 확인하면 된다.

10. **생성자**

    1. Constructor
       - 인스턴스를 생성할 때 호출하는 메서드
       - 생성자의 이름은 클래스 이름과 동일
       - 생성자는 new로 호출할 수 있음
       - 생성자는 메모리 할당을 수행하고 할당받은 메모리의 참조를 리턴
       - 생성자를 만들지 않으면 매개변수가 없는 생성자가 제공
       - 생성자를 직접 작성하면 기본적으로 제공되는 생성자는 소멸
       - 생성자는 리턴 타입이 없다.
       - 생성자도 Overloading이 가능
    2. 생성자를 만드는 방식

       ```java
       [접근 지정자] 클래스이름(매개변수 나열) {
       	수행할 작업
       }
       ```

    3. 생성자 호출

       인스턴스 속성들의 초기화: 기본값이 아닌 상수로 초기화하거나 외부로부터 주입받아서 초기화

       상위 클래스에 매개변수가 없는 생성자(Default Constructor)가 없어서 생성

    4. 생성자 만들기

       VO(Value Object - 여러 개의 데이터를 하나로 묶어서 표현하기 위한 클래스, RDBMS에서의 테이블) 클래스를 생성

       **예시 코드. 회원 정보를 저장하기 위한 클래스 - Member**

       - email - 이메일 - String
       - password - 비밀번호 - String
       - nickname - 대화명 - String[]
       - birthday - 생년월일 - java.util.Date
       - married - 혼인여부 - boolean
       - age - 나이 - in

       속성 값을 설정하기 위해서 6개의 sette 메서드를 호출하기 보다는 데이터가 미리 준비되어 있다면 바로 초기화하는 것이 효율적이다.

       이런 작업을 위해서 별도의 메서드를 만들어서 호출하는게 아니라 생성자를 추가해서 이 작업을 수행하는 것이 효율적이다.

       매개변수가 있는 생성자를 만들면 매개변수가 없는 생성자가 소멸된다. 즉, 매개변수가 있는 생성자를 만들 때는 되도록이면 매개변수가 없는 생성자도 추가해주는 것이 좋다.

       최근에는 라이브러리를 이용해서 속서을 정의하는 것 이외의 작업들을 어노테이션을 이용해서 생성하기도 한다.

    5. 일련번호 생성

       static 속성은 클래스 안에 1개만 만들어지고 instance 속성은 instance 별로 별도로 소유한다.

       static 변수의 값을 시작할 번호로 초기화를 하고 생성자에서 static 변수의 값을 변경하면서 instace 속성에 대입하면 된다.

       getter와 setter를 만들어서 제공하면 일련번호를 확인하는 것과 재설정하는 작업을 제공하는 것이다.

       **예시 코드. 테이블과 유사한 VO 클래스 생성 - Data**

    6. Instant Filed Initializer
       - 클래스 안에 { }에 작성
       - { } 안에서는 static 속성과 instance 속성 모두 사용 가능
       - instance 속성을 초기화할 목적으로 사용
       - 이 블럭은 여러 개 작성 가능하고 생성자보다 먼저 호출됨.
       - 내부적으로는 init이라는 메서드로 만들어짐.
    7. 생성 순서

       클래스: static 속성을 메모리 할당하고 static { } 코드를 수행

       인스턴스: instance 속성을 메모리 할당하고 { } 코드를 수행하고 생성자를 수행

11. **메모리 정리**

    Java에서는 Garbage Collection이 Heap(인스턴스가 존재하는 영역) 메모리에 대한 정리를 수행

    더 이상 참조되지 않는 인스턴스가 정리 대상이 된다.

    Garbage Collection은 우선 순위가 낮은 Daemon Thread 형태로 만들어져 있어서 호출 순서가 늦다.

    정확한 호출 시점을 예측할 수 없다. 강제로 호출해주는 System.gc() 메서드가 있어 PC용 응용프로그램에서는 호출해도 되지만 Android와 Server Application에서는 직접 호출을 권장하지 않는다.

12. **초기화나 생성 시점**

    여러 클라이언트의 요청을 처리하는 Server Application은 빠르게 처리가 이루어져야 한다. Server Application은 작업을 처리하기 전에 모든 준비를 해두는 것이 좋다.

    Client Application은 속도도 중요하지만 가용성도 중요하게 평가한다. 사용을 할 때 생성하거나 초기화해도 된다.

13. package

    유사한 기능을 수행하는 클래스의 집합 - 디렉토리와 유사

    배포의 단위

    하나의 패키지에서 클래스 이름은 식별이 되어야 한다. 다른 패키지끼리는 동일한 클래스 이름이 가능. 클래스 이름은 `패키지이름.클래스이름` 으로 만들어지기 때문이다. 이름 1과 이름1.이름2 형태의 패키지가 존재하는 경우 이 2개의 패키지는 별개로 간주한다.

    import 이름1.\*; 을 했다고 해서 이름1.이름2 패키지에 있는 클래스 이름을 줄여쓸 수는 없다.

    package를 배포할 때는 압축을 해서 배포를 한다.

    jar: 자바 애플리케이션 - main 메서드를 가진 클래스가 2개 이상이면 안됨.

    war: 자바 웹 애플리케이션

    패키지를 선택하고 마우스 오른쪽을 눌러서 export를 선택하면 만들 수 있다.
